<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2022-04-11 Mon 08:48 -->
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Logical Framework</title>
<meta name="author" content="Alex Nelson" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=Spectral&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Merriweather" rel="stylesheet">
<div style="display: none"> \(
\newcommand\D{\mathrm{d}}
\newcommand\E{\mathrm{e}}
\newcommand\I{\mathrm{i}}
\newcommand\bigOh{\mathcal{O}}
\newcommand{\cat}[1]{\mathbf{#1}}
\newcommand\curl{\vec{\nabla}\times}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\)</div>
<link rel="stylesheet" type="text/css" href="../../css/stylesheet.css" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./index.html"> UP </a>
 |
 <a accesskey="H" href="../../index.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Logical Framework</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#h-00377e54-8444-49ae-baa8-e40be87ad7bb">1. Introduction</a>
<ul>
<li><a href="#h-a0eff2b0-41d2-49e3-8cc2-92df7dfd3398">1.1. Adequacy Theorem</a></li>
</ul>
</li>
<li><a href="#h-83f982ca-e53c-4a1d-91f6-17afd7425766">2. Dependent Types</a></li>
<li><a href="#h-b0c1ffaf-6bc0-42eb-9f14-afde1f6bb30d">3. Higher-Order Logic</a></li>
<li><a href="#h-6ee297d4-630c-433b-a999-bb00e605250d">4. Open Questions</a></li>
<li><a href="#h-0e7d2aae-438c-493c-86cf-1325bbad4910">5. References</a></li>
</ul>
</div>
</div>

<div id="outline-container-h-00377e54-8444-49ae-baa8-e40be87ad7bb" class="outline-2">
<h2 id="h-00377e54-8444-49ae-baa8-e40be87ad7bb"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-h-00377e54-8444-49ae-baa8-e40be87ad7bb">
<p>
The basic idea of a logical framework is that we want to:
</p>
<ul class="org-ul">
<li>describe a given logic (from a large class of deductive systems)</li>
<li>emulate reasoning within the aforementioned logic</li>
</ul>

<p>
This is all rather vague, since "deductive system" is vague (and if we
try to make the notion more precise, we tend to omit important systems).
But a large class of deductive systems may be described in terms of
judgements and inference rules.
</p>

<p>
From this perspective, a logical framework is then a metalanguage with
some prescribed manner to encode a judgement (sometimes denoted using
the Oxford brackets \([\![J]\!]\) for the encoding of the judgement \(J\))
and inference rules.
</p>

<p>
If we try to make this more precise, then we commit ourselves to a
particular foundation (i.e., to a particular logical framework). I'll
just discuss two particular popular families of logical frameworks.
</p>
</div>

<div id="outline-container-h-a0eff2b0-41d2-49e3-8cc2-92df7dfd3398" class="outline-3">
<h3 id="h-a0eff2b0-41d2-49e3-8cc2-92df7dfd3398"><span class="section-number-3">1.1.</span> Adequacy Theorem</h3>
<div class="outline-text-3" id="text-h-a0eff2b0-41d2-49e3-8cc2-92df7dfd3398">
<p>
Usually, the critical steps when working with a logical framework
amounts to:
</p>

<ol class="org-ol">
<li>Write down the judgements and inference rules for your "object logic"</li>
<li>Devise an encoding for them in your logical framework</li>
<li>Prove your encoding is adequate (i.e., there is a bijection between
the object logic and the encoded version), so that valid proofs using
the encoded system corresponds to valid proofs in the "object logic"</li>
</ol>

<p>
This notion of adequacy seems to be introduced by Honsell, Plotkin, and Harper's
paper "Framework for defining logics". In practice, this amounts to
producing a so-called <dfn>Adequacy Theorem</dfn> to prove we have a
bijection. For an example of this "in the wild", see Harper and Licata's
<a href="https://www.cs.cmu.edu/~rwh/papers/mech/jfp07.pdf">"Mechanizing Metatheory in a Logical Framework"</a> (viz., &sect;3).
</p>
</div>
</div>
</div>

<div id="outline-container-h-83f982ca-e53c-4a1d-91f6-17afd7425766" class="outline-2">
<h2 id="h-83f982ca-e53c-4a1d-91f6-17afd7425766"><span class="section-number-2">2.</span> Dependent Types</h2>
<div class="outline-text-2" id="text-h-83f982ca-e53c-4a1d-91f6-17afd7425766">
<p>
Historically, this was the first way logical frameworks emerged,
specifically in de Bruijn's <a href="automath.html">Automath</a>. If we wanted to encode a logic \(L\)
in dependent type theory, we start with a judgement in \(L\) like
</p>

\begin{equation}
\Gamma\vdash_{L}\varphi
\end{equation}

<p>
We begin by defining primitive notions of the logic in Automath (or the
dependently-typed lambda calculus) \(\bar\Gamma_{L}\), then we have some
encoding \(T(\varphi)\) of the judgement \(\varphi\) and an encoding
\(T(\Gamma)\) of the context, and we have now to produce a proof term \(p\)
of the encoded judgement-as-type:
</p>

\begin{equation}
\bar\Gamma_{L}, T(\Gamma)\vdash_{LF} p : T(\varphi)
\end{equation}

<p>
Harper, Honsell, and Plotkin make this rigorous in their LF type theory.
</p>
</div>
</div>

<div id="outline-container-h-b0c1ffaf-6bc0-42eb-9f14-afde1f6bb30d" class="outline-2">
<h2 id="h-b0c1ffaf-6bc0-42eb-9f14-afde1f6bb30d"><span class="section-number-2">3.</span> Higher-Order Logic</h2>
<div class="outline-text-2" id="text-h-b0c1ffaf-6bc0-42eb-9f14-afde1f6bb30d">
<p>
Following Paulson's "Foundation of a Generic Theorem Prover" (see &sect;3,
definition 1) we can encode a logic in higher-order logic, where we add
some primitive definitions to the logical framework \(\mathcal{M}\) to get
\(\mathcal{M}_{L}\), a way to encode judgements \(J\) as formulas \([\![J]\!]\),
and inference rules
</p>

\begin{equation}
\frac{J_{1}\quad\dots\quad J_{n}}{J}C
\end{equation}

<p>
with side condition(s) \(C\), premises \(J_{1}\), &#x2026;, \(J_{n}\), and
conclusion \(J\), may be encoded as an implication:
</p>

\begin{equation}
[\![C]\!]\implies([\![J_{1}]\!]\implies[\dots\implies([\![J_{n}]\!]\implies [\![J]\!])]).
\end{equation}

<p>
This suffices to provide a framework for encoding any judgement of the
deductive system, and reasoning within that deductive system.
</p>
</div>
</div>

<div id="outline-container-h-6ee297d4-630c-433b-a999-bb00e605250d" class="outline-2">
<h2 id="h-6ee297d4-630c-433b-a999-bb00e605250d"><span class="section-number-2">4.</span> Open Questions</h2>
<div class="outline-text-2" id="text-h-6ee297d4-630c-433b-a999-bb00e605250d">
<p>
Here are some open questions (to me), and I'd be interested if anyone
has solutions.
</p>

<p>
<b>Question 1: Define "logic".</b> A logical framework "encodes" a "logic",
but I have not seen "logic" rigorously defined anywhere. What can be
encoded? What can't be?
</p>

<p>
It seems the consensus (either explicitly or implicitly) is: a logic is
a system described by judgements and inference rules. I think this
intersects are large number of logics, and there are a large number of
systems (described by judgements and inference rules) which are not logics.
Is this description "optimal" in the sense that it's pithy and supports
"enough" systems of logic that refining it further produces a baroque definition
that's unworkable in practice?
</p>

<p>
<b>Question 2: Can different logical frameworks support disjoint sets of logics?</b>
Presuming there is some "sufficient" definition from the previous
question, does a logical framework need to be able to encode <i>all</i> of
the logics? Or can a logical framework encode a large subset of logics?
In the latter case, can different logical frameworks encode disjoint
subsets of logics? What's the relationship between facets of logical
frameworks and the encodable logics?
</p>

<p>
<b>Question 3: Can FOL + \(\mathsf{ZF}^{++}\) be a logical framework?</b> Can
we use first-order logic and set theory as a logical framework? I
haven't seen anyone say it's possible (conversely, I haven't seen anyone
say it's <i>impossible</i> either).
</p>

<p>
(I am facetiously referring to "some suitable set theory" as \(\mathsf{ZF}^{++}\),
analogous to C++.)
</p>
</div>
</div>

<div id="outline-container-h-0e7d2aae-438c-493c-86cf-1325bbad4910" class="outline-2">
<h2 id="h-0e7d2aae-438c-493c-86cf-1325bbad4910"><span class="section-number-2">5.</span> References</h2>
<div class="outline-text-2" id="text-h-0e7d2aae-438c-493c-86cf-1325bbad4910">
<ul class="org-ul">
<li>N. G. de Bruijn,<br>
"A survey of the project Automath".<br>
In <i>Selected Papers on Automath</i>, <a href="https://pure.tue.nl/ws/files/1892191/597622.pdf">PDF</a></li>
<li>R. Harper, F. Honsell and G. Plotkin,<br>
"A Framework for Defining Logics".<br>
In <i>Symposium on Logic in Computer Science</i>, 1987, pages 194-204;
<a href="https://homepages.inf.ed.ac.uk/gdp/publications/Framework_Def_Log.pdf">Eprint</a></li>
<li>Lawrence Paulson,<br>
"The Foundation of a Generic Theorem Prover".<br>
<a href="https://arxiv.org/abs/cs/9301105">arXiv:cs/9301105</a>, 37 pages.</li>
<li>Robert Harper and Daniel R. Licata, <br>
<a href="https://www.cs.cmu.edu/~rwh/papers/mech/jfp07.pdf">"Mechanizing Metatheory in a Logical Framework"</a>.<br>
<i>Journal of functional programming</i> <b>17</b>, no. 4-5 (2007) pp.613&#x2013;673.</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="postamble">Last Updated 2022-02-22 Tue 08:31.</p>
</div>
</body>
</html>