<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Equational Reasoning in Standard ML</title>
<meta name="author" content="Alex Nelson" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=Spectral&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Merriweather" rel="stylesheet">
<div style="display: none"> \(
\DeclareMathOperator{\tr}{tr}
\newcommand\D{\mathrm{d}}
\newcommand\E{\mathrm{e}}
\newcommand\I{\mathrm{i}}
\newcommand\bigOh{\mathcal{O}}
\newcommand{\cat}[1]{\mathbf{#1}}
\newcommand\curl{\vec{\nabla}\times}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
% For +---- metric
\newcommand{\BDpos}{}
\newcommand{\BDneg}{-}
\newcommand{\BDposs}{\phantom{-}}
\newcommand{\BDnegg}{-}
\newcommand{\BDplus}{+}
\newcommand{\BDminus}{-}
% For -+++ metric
\newcommand{\BDpos}{-}
\newcommand{\BDposs}{-}
\newcommand{\BDneg}{}
\newcommand{\BDnegg}{\phantom{-}}
\newcommand{\BDplus}{-}
\newcommand{\BDminus}{+}
\)</div>
<link rel="stylesheet" type="text/css" href="../../css/stylesheet.css" />
<script>
  window.MathJax = {
    loader: {source: { '[tex]/amsCd': '[tex]/amscd',
                       '[tex]/AMScd': '[tex]/amscd'}},
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      inlineMath: {'[+]': [['$', '$']]},
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script  type="text/javascript"
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./index.html"> UP </a>
 |
 <a accesskey="H" href="../../index.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Equational Reasoning in Standard ML</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#h-b5b06cfd-93e5-4383-8b89-f4f872d9ee67">1. Overview</a></li>
<li><a href="#h-eb7b240e-e63c-4035-89a9-2c55052df004">2. Definitions</a></li>
<li><a href="#h-57e4c16f-fd17-4b6f-ab48-8527cf6a3ece">3. Provisional Definition of Extensional Equivalence</a>
<ul>
<li><a href="#h-b1cbf2e8-1917-4839-b783-103116c2fa2b">3.1. For "base" types</a></li>
<li><a href="#h-501c753f-588d-4a7a-9436-33afc343fb04">3.2. For Function Values</a></li>
<li><a href="#h-53a1480a-6ff2-4505-a7f8-4c752986c693">3.3. For Functions</a></li>
<li><a href="#h-aab6de97-f44c-4910-ba94-b074fa9300ca">3.4. General Definition</a></li>
<li><a href="#h-784e6087-72e0-42be-b709-ac98263747ab">3.5. Using this Definition</a></li>
</ul>
</li>
<li><a href="#h-d74b14b3-96ba-441b-bfee-227798e0544a">4. Initial Specification of a Few Types</a>
<ul>
<li><a href="#h-d3e60ff9-e8a7-4e93-b6dd-aa735f544af6">4.1. Integers</a></li>
<li><a href="#h-aa97e59e-f741-47fa-9977-dbcc09500b15">4.2. Booleans</a></li>
</ul>
</li>
<li><a href="#h-1bb08f53-6114-4227-8897-b85963f0d0b8">5. Basic Properties</a></li>
<li><a href="#h-bc08c8a9-465d-41cb-b9fc-0ad222f6410d">6. Reductions</a></li>
<li><a href="#h-1b53c25f-fb11-47bc-8174-d73aa0dfb041">7. Type-Directed Rules</a></li>
<li><a href="#h-517e93d9-e267-41b9-86d7-ec893dfe7f73">8. Valuability</a></li>
<li><a href="#h-29c752da-965c-44b2-97fa-0375f6722045">9. Inversions</a></li>
<li><a href="#h-1e7d947c-6fb0-456c-b6d0-110da995dcf1">10. Concluding Remarks</a></li>
<li><a href="#h-63a006e4-bb72-451a-b884-463a6e9e9d42">11. References</a></li>
</ul>
</div>
</div>
<div id="outline-container-h-b5b06cfd-93e5-4383-8b89-f4f872d9ee67" class="outline-2">
<h2 id="h-b5b06cfd-93e5-4383-8b89-f4f872d9ee67"><span class="section-number-2">1.</span> Overview</h2>
<div class="outline-text-2" id="text-h-b5b06cfd-93e5-4383-8b89-f4f872d9ee67">
<p>
The excitement with statically-typed functional programming is that we
can reason about it. The technical term is "equational reasoning" and
resembles Dijkstra's <a href="https://en.wikipedia.org/wiki/Structured_derivations">structured derivations</a>. For purely functional
languages, we can use equational reasoning for the entire program.
</p>

<div class="remark" id="org34deff4">
<p>
The critical property enabling us to reason about functional programs is
<b>referential transparency.</b> The only two features of Standard ML which
hinders referential transparency: IO, and references. (IO is a thorny
issue in functional programming.)
</p>

</div>

<p>
Since Standard ML has some impure aspects, and has eager evaluation,
there are some subtleties about how to reason about ML code.
</p>

<p>
<b>Moral:</b> Well-written functional code corresponds to its own correctness
proof.
</p>
</div>
</div>
<div id="outline-container-h-eb7b240e-e63c-4035-89a9-2c55052df004" class="outline-2">
<h2 id="h-eb7b240e-e63c-4035-89a9-2c55052df004"><span class="section-number-2">2.</span> Definitions</h2>
<div class="outline-text-2" id="text-h-eb7b240e-e63c-4035-89a9-2c55052df004">
<p>
We have an equivalence, in ascii written <code>==</code> (so <code>e1 == e2 : T</code> is a
predicate on two closed expressions <code>e1</code> and <code>e2</code>, both have the same
type <code>T</code>). In math, on paper, we write \(e_{1}\cong e_{2} : \tau\). We
usually suppress the type.
</p>

<ul class="org-ul">
<li><code>e value</code> means that <code>e</code> is a value; not every expression has a value
(e.g., <code>5 div 0</code>).
<ul class="org-ul">
<li>For now, values may be described inductively as:
<ul class="org-ul">
<li>The basic types like numbers, strings, characters,</li>
<li>applications of datatype constructors to values,</li>
</ul></li>
<li>More generally, "values" would be <i>syntactical values</i> or
"non-expansive expressions" as found in chapter 4 of the definition
of Standard ML (1997 revision).</li>
</ul></li>
<li><code>e valuable</code> mean "There exists a <code>v</code> such that <code>v value</code> and <code>e == v</code>"
<ul class="org-ul">
<li>If an expression raises an exception, then it is not valuable.</li>
</ul></li>
<li><code>f : T1 -&gt; T2, f total</code> means "For all values <code>v1 : T1</code>, if <code>v1 value</code>,
then <code>(f v2) valuable</code>."
<ul class="org-ul">
<li>Examples: <code>(fn s =&gt; s)</code>, <code>op +</code>, <code>Int.toString</code></li>
<li>Non-Examples: <code>div</code>, <code>exp</code></li>
</ul></li>
<li>It's common to abuse language and write: "for all values <code>e : T</code>&#x2026;"
or even "for all <code>v : T</code> &#x2026;" to mean "for all <code>e : T</code>, if <code>e value</code>,
then&#x2026;".
Specifically, this means a quantifier over arbitrary expressions must
be explicitly indicates as, "For all expressions <code>e : T</code> &#x2026;".</li>
<li>We write <code>e'[e/x]</code> for substitution of <code>e</code> for <code>x</code> in <code>e'</code>.</li>
<li><b>Reduction</b> of an expression is written <code>e ==&gt; e'</code> (or on paper as
\(e \Longrightarrow e'\)) and is defined using the operational semantics
of Standard ML. It does not necessarily correspond to the steps the
computer takes when evaluating a Standard ML expression (since
optimizations may occur, etc.).
<ul class="org-ul">
<li>We write \(e\stackrel{k}{\Longrightarrow} e'\) for "\(e\) reduces to
\(e'\) in \(k\) steps of reduction"</li>
<li>If we have \(e\Longrightarrow e'\), then we mean "\(e\) reduces to \(e'\)
in zero or more steps of reduction"</li>
</ul></li>
<li><b>Evaluation</b> of an expression is denoted \(e\hookrightarrow v\)
<ul class="org-ul">
<li>Evaluation and reduction are related in the sense that if \(e\hookrightarrow v\)
then either \(e\) is \(v\) already or \(e\stackrel{1}{\Longrightarrow}e_{1}\Longrightarrow v\)</li>
</ul></li>
<li>We write <code>e |-&gt; e'</code> for one step of calculation or reduction,
<code>e |=&gt; e''</code> for multiple parallel steps of calculation or reduction,
and <code>e ==&gt; e'''</code> for an arbitrary-but-finite number of steps of reduction.
<ul class="org-ul">
<li>Observe if <code>e |-&gt; e'</code>, then <code>e |=&gt; e'</code></li>
<li>If <code>e |=&gt; e'</code>, then <code>e ==&gt; e'</code></li>
<li>If <code>e1 ==&gt; e2</code> and <code>e2 ==&gt; e3</code>, then <code>e1 ==&gt; e3</code>.</li>
<li><b>Example:</b> evaluating <code>(1 + 2)*(3 + 4)</code>
<ul class="org-ul">
<li>We have <code>(1 + 2)*(3 + 4) |=&gt; 3*7</code> since <code>(1 + 2) |=&gt; 3</code> and
separately <code>3 + 4 |=&gt; 7</code>; and then we have <code>3*7 |=&gt; 21</code>.
So <code>|=&gt;</code> does one step of evaluation on disjoint subexpressions.</li>
<li>But we also have <code>(1 + 2)*(3 + 4) ==&gt; 21</code> done in one step.</li>
<li>The longest route is to do one step of evaluation at a time, which
could look something like: <code>(1 + 2)*(3 + 4) |-&gt; 3*(3 + 4) |-&gt; 3*7 |-&gt; 21</code>,
but there are other possibilities.</li>
</ul></li>
<li>Syntax on paper, we would write:
<ul class="org-ul">
<li><code>e ==&gt; e'</code> as \(e \Longrightarrow e'\)</li>
<li><code>e |-&gt; e'</code> as \(e \mapsto e'\)</li>
<li><code>e |=&gt; e'</code></li>
<li>\(e\hookrightarrow v\) for \(e\Longrightarrow v\) and \(v\) is a value,
i.e., \(e\) is valuable and \(e\Longrightarrow v\)</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-h-57e4c16f-fd17-4b6f-ab48-8527cf6a3ece" class="outline-2">
<h2 id="h-57e4c16f-fd17-4b6f-ab48-8527cf6a3ece"><span class="section-number-2">3.</span> Provisional Definition of Extensional Equivalence</h2>
<div class="outline-text-2" id="text-h-57e4c16f-fd17-4b6f-ab48-8527cf6a3ece">
<p>
There are several cases to the definition of extensional
equivalence. Really, there is an abstract definition, and these several
cases are theorems&#x2026;but the abstract definition is too abstract.
</p>
</div>
<div id="outline-container-h-b1cbf2e8-1917-4839-b783-103116c2fa2b" class="outline-3">
<h3 id="h-b1cbf2e8-1917-4839-b783-103116c2fa2b"><span class="section-number-3">3.1.</span> For "base" types</h3>
<div class="outline-text-3" id="text-h-b1cbf2e8-1917-4839-b783-103116c2fa2b">
<p>
Let \(e\), \(e'\) be two expressions of the same base type (e.g., <code>int</code>,
<code>char</code>, <code>string</code>, <code>bool</code>, <code>word</code>, <code>unit</code>, etc.). We say they are
<dfn>Extensionally Equivalent</dfn>, written \(e\cong e'\), if one of the
following is true:
</p>

<ol class="org-ol">
<li>Evaluation of <code>e</code> produces the same value as the evaluation of <code>e'</code>,</li>
<li>Evaluation of <code>e</code> raises the same exception as the evaluation of
<code>e'</code>, or</li>
<li>Both loop forever.</li>
</ol>

<div class="remark" id="orgc31cd66">
<p>
We can see that two values of the same base type are extensionally
equivalent iff they are identical (modulo silly encoding issues, like
<code>0x10</code> and <code>16</code> are the same value but expressed in superficially
different literals).
</p>

</div>

<p>
Also notice, if we have the product of base types, extensional
equivalence carries over component-wise.
</p>
</div>
</div>
<div id="outline-container-h-501c753f-588d-4a7a-9436-33afc343fb04" class="outline-3">
<h3 id="h-501c753f-588d-4a7a-9436-33afc343fb04"><span class="section-number-3">3.2.</span> For Function Values</h3>
<div class="outline-text-3" id="text-h-501c753f-588d-4a7a-9436-33afc343fb04">
<p>
We say two function values <code>f : T -&gt; T'</code> and <code>g : T -&gt; T'</code> of the same
type are extensionally equivalent whenever <code>f(v) == g(w)</code> for all
extensionally equivalent argument values <code>v : T</code> and <code>w : T</code>.
</p>

<div class="remark" id="org307c822">
<p>
A "function value" is an anonymous lambda expression <code>fn x =&gt; e</code>
together with a (possibly empty) environment of bindings for any
"nonlocal variables" appearing in the body of the function. This pairing
(of a lambda expression plus an environment) form a <dfn>Closure</dfn>.
</p>

</div>
</div>
</div>
<div id="outline-container-h-53a1480a-6ff2-4505-a7f8-4c752986c693" class="outline-3">
<h3 id="h-53a1480a-6ff2-4505-a7f8-4c752986c693"><span class="section-number-3">3.3.</span> For Functions</h3>
<div class="outline-text-3" id="text-h-53a1480a-6ff2-4505-a7f8-4c752986c693">
<p>
We will say two <i>expressions</i> of type <code>T -&gt; T'</code> are extensionally
equivalent if one of the following hold:
</p>

<ol class="org-ol">
<li>they both evaluate to extensionally equivalent function values,</li>
<li>they both raise extensionally equivalent exceptions when evaluates, or</li>
<li>both loop forever when evaluated.</li>
</ol>
</div>
</div>
<div id="outline-container-h-aab6de97-f44c-4910-ba94-b074fa9300ca" class="outline-3">
<h3 id="h-aab6de97-f44c-4910-ba94-b074fa9300ca"><span class="section-number-3">3.4.</span> General Definition</h3>
<div class="outline-text-3" id="text-h-aab6de97-f44c-4910-ba94-b074fa9300ca">
<p>
Two expressions <code>e</code> and <code>e'</code> are extensionally equivalent provided (a)
they are of the same type, and (b) one of the following holds:
</p>

<ol class="org-ol">
<li>they both evaluate to extensionally equivalent values, or</li>
<li>they both raise extensionally equivalent exceptions when evaluates, or</li>
<li>both loop forever when evaluated.</li>
</ol>

<p>
(Two exceptions are extensionally equivalent if they are the same kind of
exception and their payloads are extensionally equivalent.)
</p>

<p>
When <code>e</code> and <code>e'</code> are extensionally equivalent, we write <code>e == e'</code> in
code and \(e\cong e'\) on paper.
</p>
</div>
</div>
<div id="outline-container-h-784e6087-72e0-42be-b709-ac98263747ab" class="outline-3">
<h3 id="h-784e6087-72e0-42be-b709-ac98263747ab"><span class="section-number-3">3.5.</span> Using this Definition</h3>
<div class="outline-text-3" id="text-h-784e6087-72e0-42be-b709-ac98263747ab">
<p>
For us to actually use this definition, we need to introduce the various
base types and germane information, like:
</p>

<ul class="org-ul">
<li>Values of the type</li>
<li>Primitive Operations provided by the Standard Basis</li>
<li>Typing rules associated with the primitive operations</li>
<li>Evaluation rules</li>
</ul>

<p>
Since most of the primitive operations are <i>functions</i> and Standard ML
is call-by-value, the only evaluation rules we really need are for the
special functions like <code>andalso</code>, <code>orelse</code>, etc.
</p>

<div class="remark" id="org16352be">
<p>
What exactly <i>are</i> "values"? They correspond to non-expansive
expressions as found in &sect;4.7 of <a href="https://smlfamily.github.io/sml97-defn.pdf">the 1997 Definition of Standard ML</a>.
These are literal values ("special constants"), tuples of non-expansive
expressions, function values, constructors applied to non-expansive
expressions, etc.
</p>

</div>
</div>
</div>
</div>
<div id="outline-container-h-d74b14b3-96ba-441b-bfee-227798e0544a" class="outline-2">
<h2 id="h-d74b14b3-96ba-441b-bfee-227798e0544a"><span class="section-number-2">4.</span> Initial Specification of a Few Types</h2>
<div class="outline-text-2" id="text-h-d74b14b3-96ba-441b-bfee-227798e0544a">
<p>
We need to specify a few of the "base types" for Standard ML before we
can reason about things. This will include giving the operational
semantics for a few of the functions found in the Standard basis library
(i.e., "primitive functions").
</p>

<p>
We should also provide similar specifications for <code>char</code>, <code>string</code>, <code>unit</code>.
The other interesting types are tuples, records, functions; we do not
specify these, but they should be understood.
</p>
</div>
<div id="outline-container-h-d3e60ff9-e8a7-4e93-b6dd-aa735f544af6" class="outline-3">
<h3 id="h-d3e60ff9-e8a7-4e93-b6dd-aa735f544af6"><span class="section-number-3">4.1.</span> Integers</h3>
<div class="outline-text-3" id="text-h-d3e60ff9-e8a7-4e93-b6dd-aa735f544af6">
<dl class="org-dl">
<dt>Type</dt><dd><code>int</code></dd>
<dt>Values</dt><dd>All the integers (this may or may not coincide with your
implementation, we assume this is the case).</dd>
<dt>Operations</dt><dd>Let <code>e1</code>, <code>e2</code> be integer expressions. Then we have the
following additional operations: <code>e1 + e2</code>, <code>e1 - e2</code>, <code>e1 * e2</code>, <code>e1 div e2</code>,
<code>e1 mod e2</code>, among many others found in the Standard Basis library's
<a href="https://smlfamily.github.io/Basis/integer.html"><code>INTEGER</code></a> signature.</dd>
<dt>Typing Rules</dt><dd>If <code>&lt;op&gt;</code> is a binary operator of integers, if <code>e1 : int</code>
and <code>e2 : int</code>, then <code>e1 &lt;op&gt; e2 : int</code>.</dd>
<dt>Evaluation</dt><dd>These operations are evaluated "from left to right" by
first evaluating the arguments, then producing the final value.</dd>
</dl>

<p>
For an explicit example of the evaluation rules, we have for addition
the following three rules:
</p>
\begin{equation}
\frac{e_{1}\stackrel{1}{\Longrightarrow}e_{1}'}{e_{1}~\mbox{\texttt{+}}~e_{2}
\stackrel{1}{\Longrightarrow}
e_{1}'~\mbox{\texttt{+}}~e_{2}}
\end{equation}
\begin{equation}
\frac{n_{1}~\mbox{value}\qquad e_{2}\stackrel{1}{\Longrightarrow}e_{2}'}{n_{1}~\mbox{\texttt{+}}~e_{2}
\stackrel{1}{\Longrightarrow}
n_{1}~\mbox{\texttt{+}}~e_{2}'}
\end{equation}
\begin{equation}
\frac{n_{1}~\mbox{value}\qquad n_{2}~\mbox{value}}{n_{1}~\mbox{\texttt{+}}~n_{2}
\stackrel{1}{\Longrightarrow}
n}
\end{equation}
<p>
where \(n\) is the integer value representing the sum of the integer
values \(n_{1}\) and
\(n_{2}\).
</p>

<p>
The other evaluation rules are similarly defined.
</p>
</div>
</div>
<div id="outline-container-h-aa97e59e-f741-47fa-9977-dbcc09500b15" class="outline-3">
<h3 id="h-aa97e59e-f741-47fa-9977-dbcc09500b15"><span class="section-number-3">4.2.</span> Booleans</h3>
<div class="outline-text-3" id="text-h-aa97e59e-f741-47fa-9977-dbcc09500b15">
<dl class="org-dl">
<dt>Type</dt><dd><code>bool</code></dd>
<dt>Values</dt><dd><code>true</code> and <code>false</code></dd>
<dt>Operations</dt><dd>Let <code>e1</code> and <code>e2</code> be Boolean expressions. Then <code>e1 andalso e2</code>,
<code>e1 orelse e2</code>, <code>not e1</code> are Boolean expressions. If <code>t1</code>, <code>t2</code> are
any two expressions of type <code>T</code>, then <code>if e1 then t1 else t2</code> is an
expression of type <code>T</code>.</dd>
<dt>Typing Rules</dt><dd>As we would expect.</dd>
<dt>Evaluation</dt><dd>The definition specifies <code>e1 andalso e2</code> is syntactic
sugar for <code>if e1 then e2 else false</code>, and <code>e1 orelse e2</code> is syntactic
sugar for <code>if e1 then true else e2</code>. By "syntactic sugar", we mean we
can replace <code>andalso</code>, <code>orelse</code> with these expressions.</dd>
</dl>
</div>
</div>
</div>
<div id="outline-container-h-1bb08f53-6114-4227-8897-b85963f0d0b8" class="outline-2">
<h2 id="h-1bb08f53-6114-4227-8897-b85963f0d0b8"><span class="section-number-2">5.</span> Basic Properties</h2>
<div class="outline-text-2" id="text-h-1bb08f53-6114-4227-8897-b85963f0d0b8">
<div class="theorem" id="orgb544cae">
<p>
For every syntactically valid Standard ML expression <code>e</code> (i.e., <code>e</code> is
well-typed and has type <code>T</code>) that we can
evaluate, exactly one of the following holds:
</p>
<ul class="org-ul">
<li><code>e ==&gt; v</code> for some value <code>v : T</code></li>
<li>the evaluation of <code>e</code> raises some exception</li>
<li>the evaluation of <code>e</code> loops forever.</li>
</ul>

</div>

<div class="proof" id="org437bd6b">
<p>
The dynamic semantics for expressions in Standard ML is given by rules
(90) through (149) of the <a href="https://smlfamily.github.io/sml97-defn.pdf">1997 Definition</a>. By inspection, we see that
these are the only possibilities. 
</p>

</div>

<div class="definition" id="orgbd4aa3f">
<p>
Two expressions <code>e</code> and <code>e'</code> are said to be <dfn>Extensionally Equivalent</dfn>
(written \(e\cong e'\) or <code>e == e'</code>) if there is a type <code>T</code> such that <code>e : T</code>
and <code>e' : T</code>, and one of the following holds:
</p>
<ul class="org-ul">
<li>there are values <code>v : T</code> and <code>v' : T</code> such that <code>e ==&gt; v</code> and <code>e' ==&gt; v'</code>
and <code>v == v'</code>, or</li>
<li>the evaluation of <code>e</code> and <code>e'</code> both raise extensionally equivalent exceptions, or</li>
<li>the evaluation of both <code>e</code> and <code>e'</code> loop forever.</li>
</ul>

</div>

<div class="proposition" id="org3fdd1d4">
<p>
If <code>e1 ==&gt; e2</code>, then <code>e1 == e2</code>.
</p>

</div>

<div class="corollary" id="orge05c640">
<p>
If <code>e1 =​=​&gt; e</code> and <code>e2 =​​=​&gt; e</code>, then <code>e1 =​= e2</code>.
</p>

</div>

<div class="theorem" id="org46daab1">
<p>
Equivalence is an equivalence relation:
</p>
<ol class="org-ol">
<li>Reflexivity: <code>e == e</code></li>
<li>Symmetry: if <code>e1 == e2</code>, then <code>e2 == e1</code></li>
<li>Transitivity: if <code>e1 == e2</code> and <code>e2 == e3</code>, then <code>e1 == e3</code>.</li>
</ol>

</div>

<div class="proof" id="org28285fe">
<p>
Proof of reflexivity: by theorem 5, there are three possibilities when
trying to evaluate <code>e</code>:
</p>
<ol class="org-ol">
<li>Consider <code>v : T</code> such that <code>e ==&gt; v</code>.
Then <code>e ==&gt; v</code> and <code>e ==&gt; v</code>, and <code>v == v</code>, which means <code>e == e</code> by
definition of extensional equivalence.</li>
<li>The evaluation of <code>e</code> raises an exception, which is extensionally
equivalent to itself. Hence <code>e == e</code> by the second clause of the
definition of extensional equivalence.</li>
<li>The evaluation of <code>e</code> loops forever. Then <code>e == e</code> by the third
clause of the definition of extensional equivalence.</li>
</ol>

<p>
Proof of symmetry is similar, working by cases given by the clauses of
the definition of extensional equivalence.
</p>

<p>
Transitivity is similarly done by cases, using symmetry of extensional
equivalence to prove the first case, and possibly some lemmas for the
remaining two cases.
</p>

</div>

<p>
Furthermore, extensional equivalence is a congruence (in the sense of
universal algebra), meaning we can replace one
expression with an equivalent one "inside" any bigger expression. Let us
formalize this notion using the idea of "referential transparency".
</p>

<div class="definition" id="org6fe57c8">
<ol class="org-ol">
<li>We call a context \(E[-]\) (i.e., an "expression with a hole")
<dfn>Referentially Transparent</dfn> if for any \(e\hookrightarrow v\)
of appropriate type we have \(E[e]\cong E[v]\).</li>
<li>We can call an expression \(e\) <dfn>Referentially Transparent</dfn>
if for every well-typed sub-expression \(e_{1}\) there is a
corresponding context \(E[-]\) such that (a) we have \(E[e_{1}]=e\) identically,
and (b) \(E[-]\) is a referentially transparent context.</li>
<li>We want to work with referentially transparent expressions.</li>
</ol>

</div>

<p>
The intuition is that referentially transparent expressions are "pure functions"
or build out of "pure functions". There are no side-effects when
evaluating a referentially transparent expression.
</p>

<div class="theorem" id="org2bb6e28">
<p>
Let \(e\) be a referentially transparent expression.
Let \(e_{1}\) be any subexpression of \(e\) and \(e = E[e_{1}]\).
Then for any well-typed expression \(e_{2}\cong e_{1}\) we have \(E[e_{1}]\cong E[e_{2}]\).
</p>

</div>

<div class="math-example" id="org04e0a59">
<p>
For applications, we may generalize from the situation with a single argument:
</p>
<ul class="org-ul">
<li>If <code>e2 == e2'</code>, then <code>e1 e2 == e1 e2'</code></li>
<li>If <code>e1 == e1'</code>, then <code>e1 e2 == e1' e2</code></li>
</ul>

</div>

<div class="math-example" id="org174840d">
<p>
On tuples, the general pattern may be gleaned from the ordered pair:
</p>
<ul class="org-ul">
<li>If <code>e1 == e1'</code>, then <code>(e1, e2) == (e1', e2)</code></li>
<li>If <code>e2 == e2'</code>, then <code>(e1, e2) == (e1, e2')</code></li>
</ul>

</div>

<div class="math-example" id="org97c0400">
<p>
If <code>e1 == e1'</code>,
then <code>(let val x = e1 in e2 end) == (let val x = e1' in e2 end)</code>.
</p>

</div>

<div class="math-example" id="org0661467">
<p>
If <code>e1 == e1'</code>, then
</p>

<pre class="example" id="orgc4d5424">
case e of [] =&gt; e1 | x :: xs =&gt; e2

==

case e of [] =&gt; e1' | x :: xs =&gt; e2
</pre>

</div>

<p>
For subexpressions which "go under binders", we quantify over all values
of the appropriate type. Consider the following examples:
</p>

<div class="math-example" id="org3fd1d7f">
<p>
(Function bodies)
If for all values <code>v : T</code>, <code>e[v/x] == e'[v/x]</code>, then
<code>(fn x : T =&gt; e) == (fn x : T =&gt; e')</code>.
</p>

</div>

<div class="math-example" id="org3e61eea">
<p>
(Let bodies)
If for all values <code>v : T</code>, we have <code>e2[v/x] == e2'[v/x]</code>, then
<code>(let val x : T = e1 in e2 end) == (let val x : T = e1 in e2' end)</code>.
</p>

</div>

<div class="math-example" id="org78b140a">
<p>
(Destructuring lists)
If for all values <code>v</code> and <code>vs</code> we have <code>e2[v/x][vs/xs] == e2'[v/x][vs/xs]</code>,
then
</p>

<pre class="example" id="org6c0982c">
case e of [] =&gt; e1 | x::xs =&gt; e2

==

case e of [] =&gt; e1 | x::xs =&gt; e2'
</pre>

</div>
</div>
</div>
<div id="outline-container-h-bc08c8a9-465d-41cb-b9fc-0ad222f6410d" class="outline-2">
<h2 id="h-bc08c8a9-465d-41cb-b9fc-0ad222f6410d"><span class="section-number-2">6.</span> Reductions</h2>
<div class="outline-text-2" id="text-h-bc08c8a9-465d-41cb-b9fc-0ad222f6410d">
<p>
Since Standard ML is call-by-value, we evaluate the arugment to a
function <i>before</i> substituting into the body. We can express this by the
following:
</p>

<div class="proposition" id="orgfb6c0f4">
<p>
If <code>e2 |-&gt; e2'</code>,
then <code>(fn x =&gt; e) e2 |-&gt; (fn x =&gt; e) e2'</code>.
</p>

</div>

<div class="remark" id="orgf1ca2a6">
<p>
We write <code>|-&gt;</code> for one step of calculation, and we write <code>==&gt;</code> to mean
there have been an arbitrary number of steps.
</p>

</div>

<div class="proposition" id="org7f2b948">
<p>
For short-circuiting boolean operators, <code>andalso</code> and <code>orelse</code>, we have
different rules of evaluation:
</p>
<ul class="org-ul">
<li>If <code>e1 ==&gt; true</code>, then <code>e1 andalso e2 ==&gt; e2</code> and <code>e1 orelse e2 ==&gt; true</code>;</li>
<li>If <code>e1 ==&gt; false</code>, then <code>e1 andalso e2 ==&gt; false</code> and <code>e1 orelse e2 ==&gt; e2</code>.</li>
</ul>

<p>
(This is because <code>andalso</code> and <code>orelse</code> are not functions)
</p>

</div>

<div class="proposition" id="orgbb8f2df">
<p>
If <code>e' value</code>, then
<code>(fn x =&gt; e) e' = e[e'/x]</code>.
</p>

</div>

<p>
The critical aspect of this second rule is the premise <code>e' value</code>. We
have several other reduction rules, which "should be obvious".
</p>

<div class="math-example" id="org047982c">
<p>
<code>(case [] of [] =&gt; e1 | x::xs =&gt; e2) == e1</code>
</p>

<p>
and
</p>

<p>
If <code>v::vs value</code>, then
<code>(case v::vs of [] =&gt; e1 | x::xs =&gt; e2) == e2[v/x][vs/xs]</code>
</p>

</div>

<div class="math-example" id="orgd0bec90">
<p>
If <code>(v1,v2) value</code>, then
<code>(let val (x,y) = (v1,v2) in e end) == e[v1/x][v2/y]</code>.
</p>

</div>

<div class="theorem" id="orgf910c7e">
<p>
If <code>e'</code> is valuable, then <code>((fn x =&gt; e) e') == (let x = e' in e end)</code>.
</p>

</div>
</div>
</div>
<div id="outline-container-h-1b53c25f-fb11-47bc-8174-d73aa0dfb041" class="outline-2">
<h2 id="h-1b53c25f-fb11-47bc-8174-d73aa0dfb041"><span class="section-number-2">7.</span> Type-Directed Rules</h2>
<div class="outline-text-2" id="text-h-1b53c25f-fb11-47bc-8174-d73aa0dfb041">
<div class="proposition" id="org297bf27">
<p>
Two functions are equivalent if they agree on all arguments; i.e.,
if for all values <code>v : T1</code> we have <code>f v == g v : T2</code>,
then <code>f == g : T1 -&gt; T2</code>.
</p>

<p>
Further, for all values <code>v</code> and <code>v'</code>,
if <code>v == v' : T1</code>, then <code>f v == g v' : T2</code>
</p>

</div>

<div class="proposition" id="org57a7153">
<p>
Constructors are injective and disjoint.
</p>

</div>

<div class="math-example" id="org465f5af">
<p>
Denote by <code>!=</code> the negation of our equivalence relation (so <code>a != b</code>
means not <code>a==b</code>), then we have
</p>
<ul class="org-ul">
<li><code>x::xs != []</code></li>
<li>If <code>y::ys == x::xs</code>, then <code>x==y</code> and <code>xs==ys</code>.</li>
</ul>

</div>
</div>
</div>
<div id="outline-container-h-517e93d9-e267-41b9-86d7-ec893dfe7f73" class="outline-2">
<h2 id="h-517e93d9-e267-41b9-86d7-ec893dfe7f73"><span class="section-number-2">8.</span> Valuability</h2>
<div class="outline-text-2" id="text-h-517e93d9-e267-41b9-86d7-ec893dfe7f73">
<div class="lemma" id="org71f0a0b">
<p>
<code>[] valuable</code>
</p>

</div>
<div class="lemma" id="orgc7790ed">
<p>
If <code>x</code> and <code>xs</code> are valuable (with values <code>v</code> and <code>vs</code>, respectively),
then <code>x::xs valuable</code>.
</p>

</div>

<div class="lemma" id="org5c82a5f">
<p>
If <code>x</code> and <code>y</code> are valuable, then <code>(x,y) valuable</code>.
</p>

</div>

<div class="lemma" id="org86f0d02">
<p>
<code>(fn x =&gt; e) valuable</code>
</p>

</div>

<div class="theorem" id="org6f31055">
<p>
If <code>f total</code> and <code>e valuable</code>,
then <code>(f e) valuable</code>.
</p>

</div>

<div class="remark" id="orgb739005">
<p>
To prove <code>f:T-&gt;T'</code> is total, we want to show <code>f v</code> is valuable for all
values <code>v:T</code>.
</p>

</div>

<div class="theorem" id="org10e522b">
<p>
Let <code>e</code>, <code>e1</code>, <code>e2</code> be expressions.
If:
</p>
<ul class="org-ul">
<li><code>e</code> is valuable,</li>
<li><code>e==[]</code> implies <code>e1 valuable</code>, and</li>
<li>for all values <code>v</code> and <code>vs</code>,
<code>e==v::vs</code> implies <code>e2[v/x][vs/xs]</code> is valuable;</li>
</ul>

<p>
&#x2026;then we have
</p>
<pre class="example" id="org5c852ba">
(case e of [] =&gt; e1 | x::xs =&gt; e2) valuable
</pre>

</div>

<div class="theorem" id="org1b3aaa8">
<p>
In general, valuability is closed under equivalence:
If <code>e==e'</code> and <code>e'</code> is valuable, then <code>e</code> is valuable.
</p>

</div>

<div class="theorem" id="org86f65cd">
<p>
(Valuable-Stepping Principle)
</p>

<p>
If <code>e2</code> is a valuable expression, then
<code>(fn x =&gt; e1) e2 == e1[e2/x]</code>.
</p>

</div>
<div class="remark" id="org67bc391">
<p>
This can be made more complicated if <code>e1</code> or <code>e2</code> is impure.
</p>

</div>
</div>
</div>
<div id="outline-container-h-29c752da-965c-44b2-97fa-0375f6722045" class="outline-2">
<h2 id="h-29c752da-965c-44b2-97fa-0375f6722045"><span class="section-number-2">9.</span> Inversions</h2>
<div class="outline-text-2" id="text-h-29c752da-965c-44b2-97fa-0375f6722045">
<p>
For closed terms, <code>e == v</code> implies <code>e</code> evaluates to a value <code>e ==&gt; v'</code> where <code>v' == v</code>. This
justifies the following inversion(s):
</p>

<div class="theorem" id="org2af63bb">
<p>
If <code>e1 e2 == v</code>,
then there exists an expression <code>e</code> and a value <code>v</code> such that
</p>

<ol class="org-ol">
<li><code>e1 == (fn x =&gt; e)</code></li>
<li><code>e2 == v2</code></li>
<li><code>e[v2/x] == v</code></li>
</ol>

</div>

<div class="theorem" id="org2e90150">
<p>
If <code>case e of [...]</code> is valuable,
then <code>e</code> is valuable.
</p>

</div>
</div>
</div>
<div id="outline-container-h-1e7d947c-6fb0-456c-b6d0-110da995dcf1" class="outline-2">
<h2 id="h-1e7d947c-6fb0-456c-b6d0-110da995dcf1"><span class="section-number-2">10.</span> Concluding Remarks</h2>
<div class="outline-text-2" id="text-h-1e7d947c-6fb0-456c-b6d0-110da995dcf1">
<p>
For the axiomatic behaviour and contracts for the standard basis
library, I would defer to the Basis library of Hamlet:
</p>

<ul class="org-ul">
<li><a href="https://github.com/rossberg/hamlet/tree/master/basis">Basis</a></li>
</ul>

<p>
HaMLet emphasizes adherence to the Standard ML definition, so this may
be useful.
</p>
</div>
</div>
<div id="outline-container-h-63a006e4-bb72-451a-b884-463a6e9e9d42" class="outline-2">
<h2 id="h-63a006e4-bb72-451a-b884-463a6e9e9d42"><span class="section-number-2">11.</span> References</h2>
<div class="outline-text-2" id="text-h-63a006e4-bb72-451a-b884-463a6e9e9d42">
<ul class="org-ul">
<li>Bob Harper, "Equational Reasoning Guide",
<a href="http://www.cs.cmu.edu/~15150/">CMU CS15-150</a>.
<ul class="org-ul">
<li><a href="https://www.cs.cmu.edu/~15150/previous-semesters/2012-spring/resources/handouts/equational.pdf">2012 Handout</a></li>
<li><a href="https://www.cs.cmu.edu/~me/courses/15-150-Spring2020/lectures/09/structural-poly.pdf">Notes on structural induction</a></li>
<li><a href="https://www.cs.cmu.edu/~me/courses/15-150-Spring2020/lectures/01/evaluation.pdf">Notes on Evaluation</a></li>
<li><a href="https://www.cs.cmu.edu/~15150/resources/lectures/notes-lec0102.pdf">Notes</a> using <code>=&gt;*</code> instead of <code>==&gt;</code></li>
</ul></li>
<li>David Walker, Princeton <a href="https://www.cs.princeton.edu/~dpw/courses/cos326-12/notes/reasoning.php">COS326</a> notes, 2012</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="postamble">Last Updated: Sat, 4 Mar 2023 11:36:08 -0800
</div>
</body>
</html>
