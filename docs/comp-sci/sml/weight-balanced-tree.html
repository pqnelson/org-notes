<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Weight-Balanced Tree - SML</title>
<meta name="author" content="Alex Nelson" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=Spectral&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Merriweather" rel="stylesheet">
<div style="display: none"> \(
\newcommand\D{\mathrm{d}}
\newcommand\E{\mathrm{e}}
\newcommand\I{\mathrm{i}}
\newcommand\bigOh{\mathcal{O}}
\newcommand{\cat}[1]{\mathbf{#1}}
\newcommand\curl{\vec{\nabla}\times}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\)</div>
<link rel="stylesheet" type="text/css" href="../../css/stylesheet.css" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./index.html"> UP </a>
 |
 <a accesskey="H" href="../../index.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Weight-Balanced Tree - SML</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#h-8246ebcc-2ee8-46a2-a4b0-ff9f094a23a6">1. Introduction</a>
<ul>
<li><a href="#h-e4dfa8a2-b105-43f1-9105-4e1ec2db2ff6">1.1. A Word about Style and Conventions</a></li>
<li><a href="#h-96e60562-fa51-44fd-b2c2-1808d0d7cc2b">1.2. Ordered Elements</a></li>
<li><a href="#h-3aafa167-010e-4967-9a53-33ee50444f24">1.3. Initial Functor</a>
<ul>
<li><a href="#h-7b18d91a-27f0-471c-b2a9-13bfb00f23f7">1.3.1. Desired API</a></li>
</ul>
</li>
<li><a href="#h-2cd10aca-84b8-4cc0-b667-001e969d5738">1.4. "Balanced" part of "Weight-Balanced Tree"</a></li>
</ul>
</li>
<li><a href="#h-e6ca4f2a-c3b3-4a42-9eda-846b020acfdf">2. Inserting a new value</a></li>
<li><a href="#h-5a8c4e4b-7c2d-410e-9940-c5d4b6ae4382">3. Querying for an Element</a></li>
<li><a href="#h-56f9e2fa-fedd-409c-9212-d511f7d42620">4. Deleting an Element</a></li>
<li><a href="#h-dba585e6-ce2d-4652-89df-759006bd8082">5. Appendix: Source Code by Files</a>
<ul>
<li><a href="#h-e0dc94f8-0daf-49c4-bfb2-3512397bc428">5.1. ord.sig</a></li>
</ul>
</li>
<li><a href="#h-a3213d67-b211-41d1-baea-406a81802cfe">6. References</a></li>
</ul>
</div>
</div>

<div id="outline-container-h-8246ebcc-2ee8-46a2-a4b0-ff9f094a23a6" class="outline-2">
<h2 id="h-8246ebcc-2ee8-46a2-a4b0-ff9f094a23a6"><span class="section-number-2">1.</span> Introduction</h2>
<div class="outline-text-2" id="text-h-8246ebcc-2ee8-46a2-a4b0-ff9f094a23a6">
<p>
Haskell uses <a href="https://en.wikipedia.org/wiki/Weight-balanced_tree">Weight-balanced trees</a> in their implementations of sets (<a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Set.html"><code>Data.Set</code></a>) and
maps (<a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Map-Strict.html"><code>Data.Map</code></a>). But their implementation is rather tricky. So I thought I would
write some notes about them. We should recall, in general, a binary tree
is inductively defined as
</p>

<div class="definition" id="org874de10">
<p>
A <dfn>Binary Tree</dfn> is either
</p>

<ol class="org-ol">
<li>the empty tree</li>
<li>a branch consisting of a value, a left subtree, a right subtree, and
possibly some metadata.</li>
</ol>

</div>

<p>
Algebraic data types were invented specifically to describe these
inductive definitions, we could easily implement a tree in Standard ML
as:
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-keyword">type</span> <span class="org-type-def">Metadata</span> = <span class="org-comment-delimiter">(* </span><span class="org-comment">whatever you want, we omit it</span><span class="org-comment-delimiter"> *)</span>;

<span class="org-keyword">datatype</span> 'a <span class="org-type-def">BinaryTree</span>
  = EmptyTree
  | Branch <span class="org-keyword">of</span> 'a * ('a BinaryTree) * ('a BinaryTree) *  Metadata;
</pre>
</div>

<p>
The <code>Branch</code> constructor takes a 4-tuple
<code>(value, left_subtree, right_subtree, metadata)</code> and produces a
<code>BinaryTree</code> object. (The ordering of the components of the 4-tuple is
arbitrary, we could easily make metadata the first component.)
</p>

<p>
What's so great about using algebraic data types for implementing trees?
It helps us reason about the code.
Whenever we write a function concerning a <code>BinaryTree</code> object, we can
write one clause to handle the case of the empty tree, and another
separate clause to handle the case of a branch. For example, we could
count the nodes in a tree thusly:
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-keyword">fun</span> <span class="org-function-name">node_count</span> EmptyTree = 0
  | node_count (Branch (_, left, right, _))
    = 1 + node_count left + node_count right;
</pre>
</div>

<p>
If the tree were ordered such that the left subtree contained all values
less than the value of the branch (and the right subtree contained all
values greater than the value of the branch), and if further the left
and right subtrees were equal in size, then searching for a value would
take about \(\log_{2}(n)\) comparisons where \(n\) is the size of the
tree. Other operations would similarly take logarithmic time, which is
desirable compared to a linked list's linear time.
</p>

<p>
We can weaken our demand that the left and right subtrees be equal in
size to be "neither branch should be horribly bigger than the other" and
still have logarithmic runtime for the tree operations.
</p>

<div class="definition" id="orgb241394">
<p>
Let \(\Delta\in\mathbb{R}\) be a positive real constant (called the <dfn>Weight Ratio</dfn>)
greater than 1.
</p>

<p>
Then a <dfn>Weight-balanced tree</dfn> is a binary tree \(T\), whose
metadata is a non-negative real number called the tree's
<dfn>Weight</dfn> denoted \(W(T)\), such that the left subtree is
<dfn>Balanced</dfn> with respect to the right subtree (in the sense that
one subtree's weights are no larger than some multiple of the weight of
the other subtree), specifically: \(\Delta\cdot W(L)\geq W(R)\) and
\(\Delta\cdot W(R)\geq W(L)\).
</p>

<p>
Phrased differently, the tree is balanced if the ratio of
weights for the subtrees \(W(L)/W(R)\) and \(W(R)/W(L)\) are not larger than
the weight-ratio parameter \(\Delta\) (i.e., \(\Delta\geq W(L)/W(R)\)
and \(\Delta\geq W(R)/W(L)\)) provided \(W(R)\neq0\) and \(W(L)\neq0\).
</p>

</div>

<p>
The common convention takes the weight of the tree \(W(T)\) to be its size
(i.e., number of nodes) denoted \(|T|\); we will take \(W(T)=1+|T|\) to
handle pathological edge-cases with populating an initially empty tree.
</p>

<p>
Now, we want to implement in Standard ML a weight-balanced tree as an
algebraic data type, something like:
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">Wishful thinking:</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">datatype</span> 'a <span class="org-type-def">WBTree</span> = Empty
                   | Branch <span class="org-keyword">of</span> int * 'a * ('a WBTree) * ('a WBTree);
</pre>
</div>

<p>
This doesn't quite work since we <i>want</i> to make the values in tree nodes
"comparable", in the sense that they have a specified <code>compare: 'a * 'a -&gt; order</code>
function given. We want this so we can enforce the desired
condition that the left subtree contains values smaller than the branch
node's value (and similarly the right subtree consists of values greater
than the branch node's value).
</p>

<p>
Standard ML's type system is too weak to enforce this demand on its
own. But SML's module system let's us guarantee this by making <code>WBTree</code>
a functor, i.e., a structure parametrized by an <code>ORDERED</code> module.
</p>
</div>

<div id="outline-container-h-e4dfa8a2-b105-43f1-9105-4e1ec2db2ff6" class="outline-3">
<h3 id="h-e4dfa8a2-b105-43f1-9105-4e1ec2db2ff6"><span class="section-number-3">1.1.</span> A Word about Style and Conventions</h3>
<div class="outline-text-3" id="text-h-e4dfa8a2-b105-43f1-9105-4e1ec2db2ff6">
<p>
Following the Standard ML Basis Library, we will adopt the naming
convention of "naming similar things similarly". So we will test for
emptiness using a function named <code>null</code> in a nod to <a href="https://smlfamily.github.io/Basis/list.html#SIG:LIST.null:VAL"><code>List.null</code></a>.
Sometimes this coincides with Haskell's naming conventions (e.g., <a href="https://hackage.haskell.org/package/containers-0.6.7/docs/Data-Map-Strict.html#v:null"><code>Data.Map.null</code></a>),
sometimes it will not.
</p>

<p>
We will also part from Standard ML when the name is too much of a
stretch (e.g., we will talk about the <code>size</code> of a tree, not the <code>length</code>
of a tree).
</p>
</div>
</div>

<div id="outline-container-h-96e60562-fa51-44fd-b2c2-1808d0d7cc2b" class="outline-3">
<h3 id="h-96e60562-fa51-44fd-b2c2-1808d0d7cc2b"><span class="section-number-3">1.2.</span> Ordered Elements</h3>
<div class="outline-text-3" id="text-h-96e60562-fa51-44fd-b2c2-1808d0d7cc2b">
<p>
Following Haskell's <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord"><code>Data.Ord</code></a> signature, we will provide a similar
<code>ORD</code> signature. Usually it suffices to just define a <code>compare</code>
function, then "fill in the gaps"; we thus define a <code>COMPARABLE</code>
signature, and then an <code>Ord</code> functor to construct a module with the
<code>ORD</code> signature.
</p>

<p>
The bare minimum we need is just a <code>compare</code> function for a type:
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">ord.sig</span><span class="org-comment-delimiter"> *)</span>

<span class="org-comment-delimiter">(* </span><span class="org-comment">minimal signature which is fleshed out in a functor</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">signature</span> <span class="org-interface-def">COMPARABLE</span> =
<span class="org-keyword">sig</span>
    <span class="org-keyword">type</span> <span class="org-type-def">t</span>;
    <span class="org-keyword">val</span> <span class="org-variable-name">compare</span> : t*t -&gt; order;
<span class="org-keyword">end</span>;
</pre>
</div>

<p>
But we will expect an ordered element to have a fuller suite of
functions, namely every possible comparison relational operator
imaginable, as well as a way to determine which value is <code>max</code> and <code>min</code>:
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">ord.sig</span><span class="org-comment-delimiter"> *)</span>

<span class="org-keyword">signature</span> <span class="org-interface-def">COMPARABLE</span> = <span class="org-comment-delimiter">(* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> *)</span>;

<span class="org-keyword">signature</span> <span class="org-interface-def">ORD</span> =
<span class="org-keyword">sig</span>
    <span class="org-keyword">type</span> <span class="org-type-def">t</span>;
    <span class="org-keyword">val</span> <span class="org-variable-name">compare</span> : t*t -&gt; order;
    <span class="org-keyword">val</span> <span class="org-variable-name">gt</span> : t*t -&gt; bool;
    <span class="org-keyword">val</span> <span class="org-variable-name">eq</span> : t*t -&gt; bool;
    <span class="org-keyword">val</span> <span class="org-variable-name">lt</span> : t*t -&gt; bool;
    <span class="org-keyword">val</span> <span class="org-variable-name">geq</span> : t*t -&gt; bool;
    <span class="org-keyword">val</span> <span class="org-variable-name">leq</span> : t*t -&gt; bool;
    <span class="org-keyword">val</span> <span class="org-variable-name">max</span> : t*t -&gt; t;
    <span class="org-keyword">val</span> <span class="org-variable-name">min</span> : t*t -&gt; t;
<span class="org-keyword">end</span>;
</pre>
</div>

<p>
We lastly will have a functor to "hydrate" the <code>ORD</code> signature, given a
module implementing <code>COMPARABLE</code> functions:
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">ord.sig</span><span class="org-comment-delimiter"> *)</span>

<span class="org-keyword">signature</span> <span class="org-interface-def">COMPARABLE</span> = <span class="org-comment-delimiter">(* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> *)</span>;

<span class="org-keyword">signature</span> <span class="org-interface-def">ORD</span> = <span class="org-comment-delimiter">(* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> *)</span>;

<span class="org-keyword">functor</span> <span class="org-module-def">Ord</span>(Ordered : COMPARABLE) : ORD <span class="org-keyword">with</span> <span class="org-keyword">type</span> <span class="org-type-def">t</span> = Ordered.t =
<span class="org-keyword">struct</span>
    <span class="org-keyword">type</span> <span class="org-type-def">t</span> = Ordered.t;
    <span class="org-keyword">val</span> <span class="org-variable-name">compare</span> = Ordered.compare;
    <span class="org-keyword">fun</span> <span class="org-function-name">gt</span> (x,y) = compare (x,y) = GREATER;
    <span class="org-keyword">fun</span> <span class="org-function-name">eq</span> (x,y) = compare (x,y) = EQUAL;
    <span class="org-keyword">fun</span> <span class="org-function-name">lt</span> (x,y) = compare (x,y) = LESS;
    <span class="org-keyword">fun</span> <span class="org-function-name">geq</span> (x,y) = not (lt (x,y));
    <span class="org-keyword">fun</span> <span class="org-function-name">leq</span> (x,y) = not (gt (x,y));
    <span class="org-keyword">fun</span> <span class="org-function-name">max</span> (x,y) = <span class="org-keyword">if</span> lt(x,y) <span class="org-keyword">then</span> y <span class="org-keyword">else</span> x;
    <span class="org-keyword">fun</span> <span class="org-function-name">min</span> (x,y) = <span class="org-keyword">if</span> lt(x,y) <span class="org-keyword">then</span> x <span class="org-keyword">else</span> y;
<span class="org-keyword">end</span>;
</pre>
</div>
</div>
</div>


<div id="outline-container-h-3aafa167-010e-4967-9a53-33ee50444f24" class="outline-3">
<h3 id="h-3aafa167-010e-4967-9a53-33ee50444f24"><span class="section-number-3">1.3.</span> Initial Functor</h3>
<div class="outline-text-3" id="text-h-3aafa167-010e-4967-9a53-33ee50444f24">
<p>
We also want a "smart constructor" which will automatically track the
size of the tree. This seems silly, but it saves a lot of concern later on.
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">bin : Node.t -&gt; t -&gt; t -&gt; t</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">fun</span> <span class="org-function-name">bin</span> x l r = T (1 + size l + size r, x, l, r);
</pre>
</div>

<p>
Then a weight-balanced tree:
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">wbtree.fun</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">functor</span> <span class="org-module-def">WBTree</span>(Node : ORD) =
<span class="org-keyword">struct</span>
   <span class="org-keyword">datatype</span> <span class="org-type-def">t</span> = E | T <span class="org-keyword">of</span> int*Node.t*t*t;

   <span class="org-keyword">val</span> <span class="org-variable-name">empty</span> = E;
   <span class="org-keyword">fun</span> <span class="org-function-name">singleton</span> (v : Node.t) = T (1, v, E, E);

   <span class="org-keyword">fun</span> <span class="org-function-name">size</span> E = 0
     | size (T (n, _, _, _)) = n;

   <span class="org-keyword">fun</span> <span class="org-function-name">bin</span> x l r = T (1 + size l + size r, x, l, r);
   <span class="org-comment-delimiter">(* </span><span class="org-comment">more to come</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">end</span>;
</pre>
</div>
</div>

<div id="outline-container-h-7b18d91a-27f0-471c-b2a9-13bfb00f23f7" class="outline-4">
<h4 id="h-7b18d91a-27f0-471c-b2a9-13bfb00f23f7"><span class="section-number-4">1.3.1.</span> Desired API</h4>
<div class="outline-text-4" id="text-h-7b18d91a-27f0-471c-b2a9-13bfb00f23f7">
<p>
We will want some functions for a weight-balanced tree:
</p>

<ul class="org-ul">
<li><code>size : t -&gt; int</code> to tell us how many nodes are in the tree;</li>
<li><code>null : t -&gt; bool</code> tests if a tree is empty;</li>
<li><code>insert : Node.t -&gt; t -&gt; t</code> to take a value and a tree, then produce a
tree with the value inserted into it;</li>
<li><code>member : Node.t -&gt; t -&gt; bool</code> to check if a value belongs to a tree
or not;</li>
<li><code>delete : Node.t -&gt; t -&gt; t</code> to remove a value from a tree (if
present), or do nothing (if absent).</li>
</ul>

<p>
There are some "nice to have" functions:
</p>

<ul class="org-ul">
<li><code>filter : (Node.t -&gt; bool) -&gt; t -&gt; t</code> to filter out all the elements
which satisfy the predicate</li>
<li><code>toList : t -&gt; Node.t list</code> to transform a weight-balanced tree to a list</li>
<li><code>foldl : (Node.t -&gt; 'a -&gt; 'a) -&gt; 'a -&gt; t -&gt; 'a</code></li>
<li><code>foldr : (Node.t -&gt; 'a -&gt; 'a) -&gt; 'a -&gt; t -&gt; 'a</code></li>
<li><code>exists : (Node.t -&gt; bool) -&gt; t -&gt; bool</code> tests each element of the
tree, and returns <code>true</code> upon the first success</li>
<li><code>all : (Node.t -&gt; bool) -&gt; t -&gt; bool</code> tests every element of the tree
against the supplied predicate, returns <code>false</code> upon first failure</li>
</ul>

<p>
The only "obvious" function which would be nice to have, but is not at
all obvious how to implement it, would be a <code>map : (Node.t -&gt; 'a) -&gt; t -&gt; 'a Tree?</code>
There is probably a way to do it, but I cannot see it at present.
</p>

<p>
We could also consider functions which merge trees together, or remove
subtrees, etc. I am not sure <i>I</i> will need them, but they are useful.
</p>
</div>
</div>
</div>

<div id="outline-container-h-2cd10aca-84b8-4cc0-b667-001e969d5738" class="outline-3">
<h3 id="h-2cd10aca-84b8-4cc0-b667-001e969d5738"><span class="section-number-3">1.4.</span> "Balanced" part of "Weight-Balanced Tree"</h3>
<div class="outline-text-3" id="text-h-2cd10aca-84b8-4cc0-b667-001e969d5738">
<p>
Our intuition is that we have a binary tree consist of a left subtree
\(L\) and a right subtree \(R\), we think they are balanced if the size of
the right subtree \(|R|\) is bounded by a multiple of the size of the left
subtree. i.e., \(\Delta\cdot|L|\geq|R|\) and a similar condition for the left
subtree \(\Delta\cdot|R|\geq|L|\) for some fixed real constant 
\(\Delta\geq1\) (usually \(\Delta\in\{2,3,4\}\)). There is some subtlety
when \(|R|=0\) or \(|L|=0\), when we should allow the other subtree to be
either empty or a singleton. Formally:
</p>

<div class="definition" id="org2eaeb84">
<p>
Let <code>Delta</code> be a positive number.
We say a weight-balanced tree \((n, x, L, R)\) is <dfn>Strictly Balanced</dfn> if:
</p>
<ul class="org-ul">
<li>When the subtrees L and R are both non-empty:
<code>Delta*size(L) &gt; size(R)</code> and <code>Delta*size(R) &gt; size(L)</code>;</li>
<li>If either subtree is empty, the other is either a singleton or empty.</li>
</ul>

<p>
We say a weight-balanced tree is <dfn>Balanced</dfn> if
</p>
<ol class="org-ol">
<li><code>Delta*(1 + size(L)) &gt;= 1 + size(R)</code> and</li>
<li><code>Delta*(1 + size(R)) &gt;= 1 + size(L)</code>.</li>
</ol>

<p>
Observe, if a weight-balanced tree is "strictly balanced", then it is
also "balanced".
</p>

</div>

<p>
The use of <code>Delta</code> allows some "wiggle room" in determining if a tree is
balanced. The larger the <code>Delta</code>, the fewer times we demand the tree be
rebalanced; on the other hand, the smaller the value of <code>Delta</code>, the
more "perfectly" balanced the tree becomes (and the quicker it is to
perform operations).
</p>

<p>
For example, when <code>Delta</code> is 2, and <code>L</code> = 5, then <code>10 &gt; R &gt;= 3</code>
is the acceptable range of sizes for the right subtree.
</p>

<p>
When <code>Delta</code> is 3 and <code>L</code> = 5, then <code>15 &gt; R &gt;= 2</code> is an acceptable range
for the sizes for the right subtree.
</p>

<div class="remark" id="org681e27e">
<p>
There is some slight variation in the definition of a WBT being
balanced. For example, Hirai and Yamamoto define it as
<code>Delta*(size(R) + 1) &gt;= size(L) + 1</code> and
<code>Delta*(size(L) + 1) &gt;= size(R) + 1</code>. This is a slightly more generous
condition; instead of <code>Delta*size(L) &gt; size(R) &gt;= ceiling(size(L)/Delta)</code>,
we would allow <code>Delta*size(L) + (Delta - 1) &gt;= size(R) &gt;= ceiling(size(L)/Delta) - 1</code>.
</p>

</div>

<p>
We will conceptually think of subtree \(T_{1}\) as
<dfn>Balanced With Respect to</dfn> subtree \(T_{2}\)
if \(\Delta\cdot(|T_{2}|+1)\geq|T_{1}|+1\). This is implemented as
<code>isBalanced T2 T1</code> &#x2014; the intuition is the curried form
<code>isBalanced T2</code> is a predicate testing if its argument (the expected \(T_{1}\)) is
balanced with respect to \(T_{2}\).
</p>

<p>
Then the assertion that the tree <i>as a whole</i> is balanced is then
<code>balanced T</code> and implemented in terms of checking if the left and right
subtrees are balanced with respect to each other (and if they are,
themselves, balanced trees). 
We could implement this predicate in Standard ML as:
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">wbtree.fun</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">functor</span> <span class="org-module-def">WBTree</span>(Node : ORD) =
<span class="org-keyword">struct</span>
   <span class="org-keyword">datatype</span> <span class="org-type-def">t</span> = E | T <span class="org-keyword">of</span> int * Node.t * t * t;

   <span class="org-keyword">val</span> <span class="org-variable-name">empty</span> = E;
   <span class="org-keyword">fun</span> <span class="org-function-name">singleton</span> (v : Node.t) = T (1, v, E, E);

   <span class="org-keyword">fun</span> <span class="org-function-name">size</span> E = 0
     | size (T (n, _, _, _)) = n;

   <span class="org-keyword">val</span> <span class="org-variable-name">delta</span> : int = 3;

   <span class="org-comment-delimiter">(* </span><span class="org-comment">isBalanced : t -&gt; t -&gt; bool</span><span class="org-comment-delimiter"> *)</span>
   <span class="org-keyword">fun</span> <span class="org-function-name">isBalanced</span> l r = delta*(size l + 1) &gt;= (size r + 1);

   <span class="org-keyword">fun</span> <span class="org-function-name">balanced</span> E = true
     | balanced (T (_, _, l, r)) = isBalanced l r <span class="org-keyword">andalso</span>
                                   isBalanced r l <span class="org-keyword">andalso</span>
                                   balanced l <span class="org-keyword">andalso</span> balanced r;
   <span class="org-comment-delimiter">(* </span><span class="org-comment">more to come</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">end</span>;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h-e6ca4f2a-c3b3-4a42-9eda-846b020acfdf" class="outline-2">
<h2 id="h-e6ca4f2a-c3b3-4a42-9eda-846b020acfdf"><span class="section-number-2">2.</span> Inserting a new value</h2>
<div class="outline-text-2" id="text-h-e6ca4f2a-c3b3-4a42-9eda-846b020acfdf">
<p>
<b>Convention:</b> values found in the left subtree are <i>less than</i> the value
of the root node, and values found in the right subtree are <i>greater than</i>
the value of the root node. (End of convention)
</p>

<p>
Suppose we had a tree of integers. Let us try maintaining our convention
with the implementation:
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">first attempt</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">fun</span> <span class="org-function-name">insert</span> x E = singleton x
  | insert x (t <span class="org-keyword">as</span> T (sz, v, l, r)) =
    <span class="org-keyword">case</span> compare(x,v) <span class="org-keyword">of</span>
       LESS =&gt; T (sz+1, v, insert x l, r)
     | EQUAL =&gt; t
     | GREATER T(sz + 1, v, l, insert x r);
</pre>
</div>

<p>
This obeys our convention: every element of the right subtree is greater
than the root of the subtree, and every element of the left subtree is
less than the root of the subtree. But what happens with
<code>foldr (fn (x,tree) =&gt; insert x tree) E [1,2,3,4,5]</code>? Well, we get
<code>T(5,1,E, T(4,2,E, T(3,3,E, T(2,4,E, T(1, 5, E, E)))))</code>. Or, graphically:
</p>


<div id="orgc23a878" class="figure">
<p><img src="../../img/tree-2.png" alt="tree-2.png">
</p>
<p><span class="figure-number">Figure 1: </span>Naive insertion of <code>[1,2,3,4,5]</code> into an empty tree.</p>
</div>

<p>
This is just a linked list with extra baggage! How can we fix this
situation?
</p>

<p>
Well, the astute reader will note our <code>insert</code> function does not check
if the subtrees are balanced. Therefore, why on Earth would anyone expect the
result to be a balanced tree?
</p>

<p>
We can remedy this by <i>balancing</i> the tree after inserting:
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">insert : Node.t -&gt; t -&gt; t</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">fun</span> <span class="org-function-name">insert</span> x E = singleton x
  | insert x (tree <span class="org-keyword">as</span> T (sz, v, l, r)) =
    <span class="org-keyword">case</span> compare(x,v) <span class="org-keyword">of</span>
       LESS =&gt; balanceL v (insert x l) r
     | EQUAL =&gt; tree
     | GREATER =&gt; balanceR v l  (insert x r);
</pre>
</div>

<p>
We call <code>balanceL</code> when inserting a new element into the left subtree
(or deleting something from the right subtree), which will guarantee the
resulting left subtree is "not too big" (i.e., balanced). The function
amounts to:
</p>

<ul class="org-ul">
<li>check if the tree constructed from the new left and right subtrees
would be balanced;
<ul class="org-ul">
<li>if so, then just construct the tree;</li>
<li>otherwise rotate right "by some amount".</li>
</ul></li>
</ul>

<p>
Similarly, <code>balanceR</code> is invoked to make sure the right subtree is "not
too big" and will restore balance by rotating left.
</p>

<p>
This is a classic trick with binary trees: rotations to rebalance them.
Tree rotation can graphically visualized as:
</p>


<div id="org772c7c4" class="figure">
<p><img src="../../img/tree-1.png" alt="tree-1.png">
</p>
<p><span class="figure-number">Figure 2: </span>Single left and single right rotations of tree with \(x < a < y < b < z\).</p>
</div>

<p>
We see that <code>size r &gt; delta*(size l)</code> is the same as <code>not isBalanced l r</code>,
i.e., the right subtree is "too big" when <code>isBalanced l r</code> is false. Similarly,
<code>size l &gt; delta*(size r)</code> is the same as <code>not isBalanced r l</code>, which
tells us the left subtree is "too big".
</p>

<p>
The implementation of this, albeit unoptimized:
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">balanceR : Node.t -&gt; t -&gt; t -&gt; t</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">fun</span> <span class="org-function-name">balanceR</span> x l r = <span class="org-keyword">if</span> isBalanced l r
                     <span class="org-keyword">then</span> T(1 + size l + size r, x, l, r)
                     <span class="org-keyword">else</span> <span class="org-comment-delimiter">(* </span><span class="org-comment">when size r &gt; delta*(size l)</span><span class="org-comment-delimiter"> *)</span> rotateL x l r;

<span class="org-comment-delimiter">(* </span><span class="org-comment">balanceL : Node.t -&gt; t -&gt; t -&gt; t</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">fun</span> <span class="org-function-name">balanceL</span> x l r = <span class="org-keyword">if</span> isBalanced r l
                     <span class="org-keyword">then</span> T(1 + size l + size r, x, l, r)
                     <span class="org-keyword">else</span> <span class="org-comment-delimiter">(* </span><span class="org-comment">when size l &gt; delta*(size r)</span><span class="org-comment-delimiter"> *)</span> rotateR x l r;
</pre>
</div>

<p>
Now it's just a matter to code up left rotations, right? Well, we also
have <i>double</i> rotations. A <dfn>double left rotation</dfn> moves a
"pivot" node "from the left" by two positions. Graphically:
</p>


<div id="org74193b2" class="figure">
<p><img src="../../img/tree-3.png" alt="tree-3.png">
</p>
<p><span class="figure-number">Figure 3: </span>Double left rotation of tree with \(x < a < y < b < z\).</p>
</div>

<p>
This is done first by performing a "local right" rotation:
</p>


<div id="org4ca1488" class="figure">
<p><img src="../../img/tree-4.png" alt="tree-4.png">
</p>
<p><span class="figure-number">Figure 4: </span>"Local right" rotation of tree with \(x < a < y < b < z\).</p>
</div>

<p>
Then a "global left" rotation yields the result. We can similarly
construct a <dfn>double right rotation</dfn> as moving a "pivot" node
"from the right" by two positions.
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">rotateL : Node.t -&gt; t -&gt; t -&gt; t</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">fun</span> <span class="org-function-name">rotateL</span> x l (r <span class="org-keyword">as</span> (T (_, _, rl, rr))) =
    <span class="org-keyword">if</span> isSingle rl rr <span class="org-keyword">then</span> singleL x l r
    <span class="org-keyword">else</span> doubleL x l r
  | rotateL _ _ _ = <span class="org-keyword">raise</span> <span class="org-string">"rotateL"</span>;

<span class="org-keyword">fun</span> <span class="org-function-name">singleL</span> x l (T (_, v, rl, rr)) = bin y (bin x l rl) rr
  | singleL _ _ _ = <span class="org-keyword">raise</span> <span class="org-string">"singleL"</span>;

<span class="org-keyword">fun</span> <span class="org-function-name">doubleL</span> x l (T (_, y, (T (_, z, rll, rlr)), rr))
    = bin z (bin x l rll) (bin y rlr rr)
  | doubleL _ _ _ = <span class="org-keyword">raise</span> <span class="org-string">"doubleL"</span>;

<span class="org-comment-delimiter">(* </span><span class="org-comment">...and analogous functions for right rotations</span><span class="org-comment-delimiter"> *)</span>
</pre>
</div>

<p>
But what is the condition for <code>isSingle</code>? Basically, if the ratio of the
size of the left subtree to the size of the right subtree is less than
the <code>Gamma</code> parameter. For us, we name <code>Gamma</code> something more relevant,
<code>ratio</code>, and this condition becomes:
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">isSingle : t -&gt; t -&gt; bool</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">fun</span> <span class="org-function-name">isSingle</span> l r = (size l + 1) &lt; ratio*(size r + 1);
</pre>
</div>

<p>
Thanks to the work of Hirai and Yamamoto, we know that <code>delta = 3</code> and
<code>ratio = 2</code> are the only integer solutions, so we pick those values.
We combine these functions together, and our functor so far becomes:
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">wbtree.fun</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">functor</span> <span class="org-module-def">WBTree</span>(Node : ORD) =
<span class="org-keyword">struct</span>
   <span class="org-keyword">datatype</span> <span class="org-type-def">t</span> = E | T <span class="org-keyword">of</span> int * Node.t * t * t;

   <span class="org-keyword">val</span> <span class="org-variable-name">empty</span> = E;
   <span class="org-keyword">fun</span> <span class="org-function-name">singleton</span> (v : Node.t) = T (1, v, E, E);

   <span class="org-keyword">fun</span> <span class="org-function-name">size</span> E = 0
     | size (T (n, _, _, _)) = n;

   <span class="org-keyword">fun</span> <span class="org-function-name">bin</span> x l r = T(1 + size l + size r, x, l, r);

   <span class="org-comment-delimiter">(* </span><span class="org-comment">laziness</span><span class="org-comment-delimiter"> *)</span>
   <span class="org-keyword">val</span> <span class="org-variable-name">compare</span> = Node.compare;

   <span class="org-keyword">val</span> <span class="org-variable-name">ratio</span> : int = 2;
   <span class="org-keyword">val</span> <span class="org-variable-name">delta</span> : int = 3;

   <span class="org-comment-delimiter">(* </span><span class="org-comment">isBalanced : t -&gt; t -&gt; bool</span><span class="org-comment-delimiter"> *)</span>
   <span class="org-keyword">fun</span> <span class="org-function-name">isBalanced</span> l r = delta*(size l + 1) &gt;= (size r + 1);

   <span class="org-keyword">fun</span> <span class="org-function-name">balanced</span> E = true
     | balanced (T (_, _, l, r)) = isBalanced l r <span class="org-keyword">andalso</span>
                                   isBalanced r l <span class="org-keyword">andalso</span>
                                   balanced l <span class="org-keyword">andalso</span> balanced r;

   <span class="org-comment-delimiter">(* </span><span class="org-comment">Helper functions to ensure the tree isBalanced</span><span class="org-comment-delimiter"> *)</span>
   <span class="org-keyword">fun</span> <span class="org-function-name">isSingle</span> a b = (size a + 1) &lt; ratio*(size b + 1);

   <span class="org-keyword">fun</span> <span class="org-function-name">singleL</span> x l (T (_, y, rl, rr)) = bin y (bin x l rl) rr
     | singleL _ _ _ = <span class="org-keyword">raise</span> (Fail <span class="org-string">"singleL"</span>);

   <span class="org-keyword">fun</span> <span class="org-function-name">doubleL</span> x l (T (_, y, (T (_, z, rll, rlr)), rr))
       = bin z (bin x l rll) (bin y rlr rr)
     | doubleL _ _ _ = <span class="org-keyword">raise</span> (Fail <span class="org-string">"doubleL"</span>);

   <span class="org-keyword">fun</span> <span class="org-function-name">singleR</span> x (T (_, y, ll, lr)) r = bin y ll (bin x lr r)
     | singleR _ _ _ = <span class="org-keyword">raise</span> (Fail <span class="org-string">"singleR"</span>);

   <span class="org-keyword">fun</span> <span class="org-function-name">doubleR</span> z (T (_, x, ll, (T (_, y, lrl, lrr)))) r
       = bin y (bin x ll lrl) (bin z lrr r)
     | doubleR _ _ _ = <span class="org-keyword">raise</span> (Fail <span class="org-string">"doubleR"</span>);

   <span class="org-keyword">fun</span> <span class="org-function-name">rotateR</span> x (l <span class="org-keyword">as</span> (T (_, _, ll, lr))) r =
       <span class="org-keyword">if</span> isSingle ll lr <span class="org-keyword">then</span> singleR x l r
       <span class="org-keyword">else</span> doubleR x l r
     | rotateR _ _ _ = <span class="org-keyword">raise</span> (Fail <span class="org-string">"rotateR"</span>);

   <span class="org-keyword">fun</span> <span class="org-function-name">rotateL</span> x l (r <span class="org-keyword">as</span> (T (_, _, rl, rr))) =
       <span class="org-keyword">if</span> isSingle rl rr <span class="org-keyword">then</span> singleL x l r
       <span class="org-keyword">else</span> doubleL x l r
     | rotateL _ _ _ = <span class="org-keyword">raise</span> (Fail <span class="org-string">"rotateL"</span>);

   <span class="org-keyword">fun</span> <span class="org-function-name">balanceR</span> x l r = <span class="org-keyword">if</span> isBalanced l r <span class="org-keyword">then</span> bin x l r
                        <span class="org-keyword">else</span> rotateL x l r;

   <span class="org-keyword">fun</span> <span class="org-function-name">balanceL</span> x l r = <span class="org-keyword">if</span> isBalanced r l <span class="org-keyword">then</span> bin x l r
                        <span class="org-keyword">else</span> rotateR x l r;

   <span class="org-comment-delimiter">(* </span><span class="org-comment">insert : Node.t -&gt; t -&gt; t</span><span class="org-comment-delimiter"> *)</span>
   <span class="org-keyword">fun</span> <span class="org-function-name">insert</span> x E = singleton x
     | insert x (tree <span class="org-keyword">as</span> T (sz, v, l, r)) =
       (<span class="org-keyword">case</span> compare(x,v) <span class="org-keyword">of</span>
           LESS =&gt; balanceL v (insert x l) r
         | EQUAL =&gt; tree
         | GREATER =&gt; balanceR v l  (insert x r));
   <span class="org-comment-delimiter">(* </span><span class="org-comment">more to come</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">end</span>;
</pre>
</div>

<div class="exercise" id="org36e9147">
<p>
Assume <code>l</code> and <code>r</code> are balanced trees, and <code>x</code> is a value such that it
lies between the subtrees.
</p>

<ol class="org-ol">
<li>Prove <code>balanceL x l r</code> produces a balanced tree.</li>
<li>Prove <code>balanceR x l r</code> produces a balanced tree.</li>
</ol>

</div>

<div class="exercise" id="orgc45ee9e">
<p>
Optimize our code. We proved it works (well, in an exercise), so prove
your optimizations "work" as well!
</p>

<p>
There are many different avenues for optimization, for example:
<code>balanceL</code> and <code>balanceR</code> recursively call functions which destruct
the arguments in the same way; is it faster to "collapse" the helper
<code>rotate</code> functions into one giant <code>balanceL</code> (and another giant
<code>balanceR</code>) function?
</p>

<p>
For other ideas, see Milan Straka's "The performance of the Haskell
<code>Containers</code> Package" (2010).
</p>

</div>
</div>
</div>

<div id="outline-container-h-5a8c4e4b-7c2d-410e-9940-c5d4b6ae4382" class="outline-2">
<h2 id="h-5a8c4e4b-7c2d-410e-9940-c5d4b6ae4382"><span class="section-number-2">3.</span> Querying for an Element</h2>
<div class="outline-text-2" id="text-h-5a8c4e4b-7c2d-410e-9940-c5d4b6ae4382">
<p>
How can we check if a tree \(T\) contains an element \(x\)? There are two
cases:
</p>

<ol class="org-ol">
<li>If \(T\) is empty, then \(x\) is not a member of it; and</li>
<li><p>
If \(T\) is not empty, then we can write \(T = (n,y,L,R)\). We should
compare \(x\) against \(y\) (the value for the node in the branch). If
they are equal, then \(x=y\) and \(x\) <i>is</i> a member of the tree.
</p>

<p>
If \(x < y\), then we should recursively check the subtree \(L\) to see
if \(x\) is a member of \(L\).
</p>

<p>
If \(x > y\), then we should recursively check the right subtree \(R\) to
see if \(x\) is a member of \(R\).
</p></li>
</ol>

<p>
Since the subtrees \(L\) and \(R\) are balanced, there would be about
\(\log_{2}(n)\) iterations when searching if \(x\) is a member of the tree.
We can easily code this up as:
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-keyword">functor</span> <span class="org-module-def">WBTree</span>(Node : ORD) =
<span class="org-keyword">struct</span>
   <span class="org-comment-delimiter">(* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> *)</span>

   <span class="org-comment-delimiter">(* </span><span class="org-comment">member : Node.t -&gt; t -&gt; bool</span><span class="org-comment-delimiter"> *)</span>
   <span class="org-keyword">fun</span> <span class="org-function-name">member</span> x E = false
     | member x (T (_,y,l,r)) = <span class="org-keyword">case</span> compare(x,y) <span class="org-keyword">of</span>
                                    EQUAL =&gt; true
                                  | LESS =&gt; member x l
                                  | GREATER =&gt; member x r;

   <span class="org-comment-delimiter">(* </span><span class="org-comment">...</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">end</span>;
</pre>
</div>

<div class="exercise" id="org516e07d">
<p>
Write a function to query for the subtree consisting of elements:
</p>
<ol class="org-ol">
<li>less than or equal to \(x\)</li>
<li>strictly less than \(x\)</li>
<li>greater than or equal to \(x\)</li>
<li>strictly greater than \(x\)</li>
</ol>

</div>
</div>
</div>

<div id="outline-container-h-56f9e2fa-fedd-409c-9212-d511f7d42620" class="outline-2">
<h2 id="h-56f9e2fa-fedd-409c-9212-d511f7d42620"><span class="section-number-2">4.</span> Deleting an Element</h2>
<div class="outline-text-2" id="text-h-56f9e2fa-fedd-409c-9212-d511f7d42620">
<p>
When deleting an element from a weight-balanced tree, we just need to do
the mirror image of an insertion (e.g., when deleting a value from the
left subtree, we need to invoke <code>balanceR</code>). The only tricky bit is what
happens when we want to delete the value <i>at</i> the root of the tree. Uh,
well, we'll just brush that problem into another function which will
<code>glue</code> the subtrees into a new weight-balanced tree.
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">delete : Node.t -&gt; t -&gt; t</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">fun</span> <span class="org-function-name">delete</span> _ E = E
  | delete x (tree <span class="org-keyword">as</span> T (_, y, l, r)) =
    (<span class="org-keyword">case</span> compare (x,y) <span class="org-keyword">of</span>
         LESS =&gt; balanceR y (delete x l) r
       | EQUAL =&gt; glue l r
       | GREATER =&gt; balanceL y l (delete x r));
</pre>
</div>

<p>
Now, how do we <code>glue</code> two weight-balanced trees together? There are some
simple cases: if <code>l</code> is empty, just return the right subtree; if <code>r</code> is
empty, return the left subtree.
</p>

<p>
When both <code>l</code> and <code>r</code> are non-empty, we have two cases:
</p>
<ol class="org-ol">
<li><code>size l &gt; size r</code>, then we merge <code>r</code> into the right subtree of <code>l</code>
and invoke <code>balanceR</code> to produce a balanced tree;</li>
<li>otherwise, we merge <code>l</code> into the left subtree of <code>r</code> and invoke
<code>balanceL</code> to produce a balanced tree.</li>
</ol>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">glue : t -&gt; t -&gt; t</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">fun</span> <span class="org-function-name">glue</span> E r = r
  | glue l E = l
  | glue (l <span class="org-keyword">as</span> T(sl, xl, ll, lr)) (r <span class="org-keyword">as</span> T(sr, xr, rl, rr))
    = <span class="org-keyword">if</span> sl &gt; sr <span class="org-keyword">then</span> (<span class="org-keyword">let</span> <span class="org-keyword">val</span> (m, l') = maxViewSure xl ll lr
                       <span class="org-keyword">in</span> balanceR m l' r
                       <span class="org-keyword">end</span>)
      <span class="org-keyword">else</span> (<span class="org-keyword">let</span> <span class="org-keyword">val</span> (m, r') = minViewSure xr rl rr
            <span class="org-keyword">in</span> balanceL m l r'
            <span class="org-keyword">end</span>);
</pre>
</div>

<p>
We can get the maximum element of a tree, plus a version of the tree
with that element <i>removed</i>. How? Simply plumb the right subtree &#x2014;
recursively examine the right subtree until it is finally empty, then
the node must contain the maximum value. Since we assume the tree is
balanced, we know that every value in the left subtree will be less than
any value in the right subtree.
</p>

<p>
We will return the rebalanced right-subtree (minus the maximum value)
and the maximum value:
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">maxViewSure : Node.t -&gt; t -&gt; t -&gt; Node.t * t</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">fun</span> <span class="org-function-name">maxViewSure</span> x l E = (x, l)
  | maxViewSure x l (T (_, xr, lr, rr)) =
    (<span class="org-keyword">case</span> maxViewSure xr lr rr <span class="org-keyword">of</span>
         (m, r') =&gt; (m, balanceL x l r'));

<span class="org-comment-delimiter">(* </span><span class="org-comment">maxView : t -&gt; (Node.t * t) option</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">fun</span> <span class="org-function-name">maxView</span> E = NONE
  | maxView (T (_, x, l, r)) = SOME (maxViewSure x l r);
</pre>
</div>

<p>
Similarly, the minimum element of the tree, and a version of the tree
with that element surgically removed. How? Well, we just keep examining
the left sub-tree until we find the smallest element. Since the tree is
assumed to be balanced, we know the left subtree consists of values
<i>guaranteed to be smaller</i> than any value found in the right
subtree. So we just surgically remove the smallest element, then
rebalance the remaining trees:
</p>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">minViewSure : Node.t -&gt; t -&gt; t -&gt; Node.t * t</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">fun</span> <span class="org-function-name">minViewSure</span> x E r = (x, r)
  | minViewSure x (T (_, xl, ll, lr)) r =
    (<span class="org-keyword">case</span> minViewSure xl ll lr <span class="org-keyword">of</span>
         (m, l') =&gt; (m, balanceR x l' r));

<span class="org-comment-delimiter">(* </span><span class="org-comment">minView : t -&gt; (Node.t * t) option</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">fun</span> <span class="org-function-name">minView</span> E = NONE
  | minView (T (_, x, l, r)) = SOME (minViewSure x l r);
</pre>
</div>

<p>
Great, now we have the ability to insert and delete elements from our
weight-balanced tree.
</p>

<div class="exercise" id="org269eef0">
<p>
Prove, if <code>tree</code> is a <i>balanced</i> weight-balanced tree containing the value <code>x</code>,
then <code>delete x tree</code> produces a <i>balanced</i> weight-balanced tree.
</p>

</div>

<div class="exercise" id="orgd8a6a07">
<p>
Change our code for the case when <code>x</code> is not contained in <code>tree</code>, then
we have <code>delete x tree</code> return the <code>tree</code> unmodified. [Hint: we cannot
use equality directly, but we know the size of the tree before and
after deletion will be the same if and only if they are the same.]
</p>

</div>

<div class="org-src-container">
<pre class="src src-sml"><span class="org-keyword">functor</span> <span class="org-module-def">WBTree</span>(Node : ORD) =
<span class="org-keyword">struct</span>
   <span class="org-keyword">datatype</span> <span class="org-type-def">t</span> = E | T <span class="org-keyword">of</span> int * Node.t * t * t;

   <span class="org-keyword">val</span> <span class="org-variable-name">empty</span> = E;
   <span class="org-keyword">fun</span> <span class="org-function-name">singleton</span> (v : Node.t) = T (1, v, E, E);

   <span class="org-keyword">fun</span> <span class="org-function-name">size</span> E = 0
     | size (T (n, _, _, _)) = n;

   <span class="org-keyword">fun</span> <span class="org-function-name">bin</span> x l r = T(1 + size l + size r, x, l, r);

   <span class="org-comment-delimiter">(* </span><span class="org-comment">laziness</span><span class="org-comment-delimiter"> *)</span>
   <span class="org-keyword">val</span> <span class="org-variable-name">compare</span> = Node.compare;

   <span class="org-keyword">val</span> <span class="org-variable-name">ratio</span> : int = 2;
   <span class="org-keyword">val</span> <span class="org-variable-name">delta</span> : int = 3;

   <span class="org-comment-delimiter">(* </span><span class="org-comment">member : Node.t -&gt; t -&gt; bool</span><span class="org-comment-delimiter"> *)</span>
   <span class="org-keyword">fun</span> <span class="org-function-name">member</span> x E = false
     | member x (T (_,y,l,r)) = <span class="org-keyword">case</span> compare(x,y) <span class="org-keyword">of</span>
                                    EQUAL =&gt; true
                                  | LESS =&gt; member x l
                                  | GREATER =&gt; member x r;

   <span class="org-comment-delimiter">(* </span><span class="org-comment">isBalanced : t -&gt; t -&gt; bool</span><span class="org-comment-delimiter"> *)</span>
   <span class="org-keyword">fun</span> <span class="org-function-name">isBalanced</span> l r = delta*(size l + 1) &gt;= (size r + 1);

   <span class="org-keyword">fun</span> <span class="org-function-name">balanced</span> E = true
     | balanced (T (_, _, l, r)) = isBalanced l r <span class="org-keyword">andalso</span>
                                   isBalanced r l <span class="org-keyword">andalso</span>
                                   balanced l <span class="org-keyword">andalso</span> balanced r;

   <span class="org-comment-delimiter">(* </span><span class="org-comment">Helper functions to ensure the tree isBalanced</span><span class="org-comment-delimiter"> *)</span>
   <span class="org-keyword">fun</span> <span class="org-function-name">isSingle</span> a b = (size a + 1) &lt; ratio*(size b + 1);

   <span class="org-keyword">fun</span> <span class="org-function-name">singleL</span> x l (T (_, y, rl, rr)) = bin y (bin x l rl) rr
     | singleL _ _ _ = <span class="org-keyword">raise</span> (Fail <span class="org-string">"singleL"</span>);

   <span class="org-keyword">fun</span> <span class="org-function-name">doubleL</span> x l (T (_, y, (T (_, z, rll, rlr)), rr))
       = bin z (bin x l rll) (bin y rlr rr)
     | doubleL _ _ _ = <span class="org-keyword">raise</span> (Fail <span class="org-string">"doubleL"</span>);

   <span class="org-keyword">fun</span> <span class="org-function-name">singleR</span> x (T (_, y, ll, lr)) r = bin y ll (bin x lr r)
     | singleR _ _ _ = <span class="org-keyword">raise</span> (Fail <span class="org-string">"singleR"</span>);

   <span class="org-keyword">fun</span> <span class="org-function-name">doubleR</span> z (T (_, x, ll, (T (_, y, lrl, lrr)))) r
       = bin y (bin x ll lrl) (bin z lrr r)
     | doubleR _ _ _ = <span class="org-keyword">raise</span> (Fail <span class="org-string">"doubleR"</span>);

   <span class="org-keyword">fun</span> <span class="org-function-name">rotateR</span> x (l <span class="org-keyword">as</span> (T (_, _, ll, lr))) r =
       <span class="org-keyword">if</span> isSingle ll lr <span class="org-keyword">then</span> singleR x l r
       <span class="org-keyword">else</span> doubleR x l r
     | rotateR _ _ _ = <span class="org-keyword">raise</span> (Fail <span class="org-string">"rotateR"</span>);

   <span class="org-keyword">fun</span> <span class="org-function-name">rotateL</span> x l (r <span class="org-keyword">as</span> (T (_, _, rl, rr))) =
       <span class="org-keyword">if</span> isSingle rl rr <span class="org-keyword">then</span> singleL x l r
       <span class="org-keyword">else</span> doubleL x l r
     | rotateL _ _ _ = <span class="org-keyword">raise</span> (Fail <span class="org-string">"rotateL"</span>);


   <span class="org-keyword">fun</span> <span class="org-function-name">balanceR</span> x l r = <span class="org-keyword">if</span> isBalanced l r <span class="org-keyword">then</span> bin x l r
                        <span class="org-keyword">else</span> rotateL x l r;

   <span class="org-keyword">fun</span> <span class="org-function-name">balanceL</span> x l r = <span class="org-keyword">if</span> isBalanced r l <span class="org-keyword">then</span> bin x l r
                        <span class="org-keyword">else</span> rotateR x l r;

   <span class="org-comment-delimiter">(* </span><span class="org-comment">insert : Node.t -&gt; t -&gt; t</span><span class="org-comment-delimiter"> *)</span>
   <span class="org-keyword">fun</span> <span class="org-function-name">insert</span> x E = singleton x
     | insert x (tree <span class="org-keyword">as</span> T (sz, v, l, r)) =
       (<span class="org-keyword">case</span> compare(x,v) <span class="org-keyword">of</span>
           LESS =&gt; balanceL v (insert x l) r
         | EQUAL =&gt; tree
         | GREATER =&gt; balanceR v l  (insert x r));

   <span class="org-comment-delimiter">(** </span><span class="org-comment">Helper functions for delete</span><span class="org-comment-delimiter"> **)</span>
   <span class="org-comment-delimiter">(* </span><span class="org-comment">Retrieve the maximal key for the set, and the set stripped</span>
<span class="org-comment">      of that element.</span><span class="org-comment-delimiter"> *)</span>
   <span class="org-keyword">fun</span> <span class="org-function-name">maxViewSure</span> x l E = (x, l)
     | maxViewSure x l (T (_, xr, lr, rr)) =
       (<span class="org-keyword">case</span> maxViewSure xr lr rr <span class="org-keyword">of</span>
            (m, r') =&gt; (m, balanceL x l r'));

   <span class="org-keyword">fun</span> <span class="org-function-name">maxView</span> E = NONE
     | maxView (T (_, x, l, r)) = SOME (maxViewSure x l r);

   <span class="org-keyword">fun</span> <span class="org-function-name">minViewSure</span> x E r = (x, r)
     | minViewSure x (T (_, xl, ll, lr)) r =
       (<span class="org-keyword">case</span> minViewSure xl ll lr <span class="org-keyword">of</span>
            (m, l') =&gt; (m, balanceR x l' r));

   <span class="org-comment-delimiter">(* </span><span class="org-comment">Retrieves the minimal key of the set, and the set is stripped of that</span>
<span class="org-comment">      element, or `NONE` if passed an empty list.</span><span class="org-comment-delimiter"> *)</span>
   <span class="org-keyword">fun</span> <span class="org-function-name">minView</span> E = NONE
     | minView (T (_, x, l, r)) = SOME (minViewSure x l r);

   <span class="org-comment-delimiter">(* </span><span class="org-comment">Glue two trees together.</span>
<span class="org-comment">      Assume that `l` and `r` are already balanced with respect to each</span>
<span class="org-comment">      other.</span><span class="org-comment-delimiter"> *)</span>
   <span class="org-keyword">fun</span> <span class="org-function-name">glue</span> E r = r
     | glue l E = l
     | glue (l <span class="org-keyword">as</span> T(sl, xl, ll, lr)) (r <span class="org-keyword">as</span> T(sr, xr, rl, rr))
       = <span class="org-keyword">if</span> sl &gt; sr <span class="org-keyword">then</span> (<span class="org-keyword">let</span> <span class="org-keyword">val</span> (m, l') = maxViewSure xl ll lr
                          <span class="org-keyword">in</span> balanceR m l' r
                          <span class="org-keyword">end</span>)
         <span class="org-keyword">else</span> <span class="org-keyword">let</span> <span class="org-keyword">val</span> (m, r') = minViewSure xr rl rr
              <span class="org-keyword">in</span> balanceL m l r'
              <span class="org-keyword">end</span>;

   <span class="org-comment-delimiter">(* </span><span class="org-comment">delete : Node.t -&gt; t -&gt; t</span><span class="org-comment-delimiter"> *)</span>
   <span class="org-keyword">fun</span> <span class="org-function-name">delete</span> _ E = E
     | delete x (tree <span class="org-keyword">as</span> T (_, y, l, r)) =
       (<span class="org-keyword">case</span> compare (x,y) <span class="org-keyword">of</span>
            LESS =&gt; balanceR y (delete x l) r
          | EQUAL =&gt; glue l r
          | GREATER =&gt; balanceL y l (delete x r));

   <span class="org-comment-delimiter">(* </span><span class="org-comment">more to come</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">end</span>;
</pre>
</div>
</div>
</div>

<div id="outline-container-h-dba585e6-ce2d-4652-89df-759006bd8082" class="outline-2">
<h2 id="h-dba585e6-ce2d-4652-89df-759006bd8082"><span class="section-number-2">5.</span> Appendix: Source Code by Files</h2>
<div class="outline-text-2" id="text-h-dba585e6-ce2d-4652-89df-759006bd8082">
</div>

<div id="outline-container-h-e0dc94f8-0daf-49c4-bfb2-3512397bc428" class="outline-3">
<h3 id="h-e0dc94f8-0daf-49c4-bfb2-3512397bc428"><span class="section-number-3">5.1.</span> ord.sig</h3>
<div class="outline-text-3" id="text-h-e0dc94f8-0daf-49c4-bfb2-3512397bc428">
<div class="org-src-container">
<pre class="src src-sml"><span class="org-comment-delimiter">(* </span><span class="org-comment">ord.sig</span><span class="org-comment-delimiter"> *)</span>

<span class="org-comment-delimiter">(* </span><span class="org-comment">minimal signature which is fleshed out in a functor</span><span class="org-comment-delimiter"> *)</span>
<span class="org-keyword">signature</span> <span class="org-interface-def">COMPARABLE</span> =
<span class="org-keyword">sig</span>
    <span class="org-keyword">type</span> <span class="org-type-def">t</span>;
    <span class="org-keyword">val</span> <span class="org-variable-name">compare</span> : t*t -&gt; order;
<span class="org-keyword">end</span>;

<span class="org-keyword">signature</span> <span class="org-interface-def">ORD</span> =
<span class="org-keyword">sig</span>
    <span class="org-keyword">type</span> <span class="org-type-def">t</span>;
    <span class="org-keyword">val</span> <span class="org-variable-name">compare</span> : t*t -&gt; order;
    <span class="org-keyword">val</span> <span class="org-variable-name">gt</span> : t*t -&gt; bool;
    <span class="org-keyword">val</span> <span class="org-variable-name">eq</span> : t*t -&gt; bool;
    <span class="org-keyword">val</span> <span class="org-variable-name">lt</span> : t*t -&gt; bool;
    <span class="org-keyword">val</span> <span class="org-variable-name">geq</span> : t*t -&gt; bool;
    <span class="org-keyword">val</span> <span class="org-variable-name">leq</span> : t*t -&gt; bool;
    <span class="org-keyword">val</span> <span class="org-variable-name">max</span> : t*t -&gt; t;
    <span class="org-keyword">val</span> <span class="org-variable-name">min</span> : t*t -&gt; t;
<span class="org-keyword">end</span>;

<span class="org-keyword">functor</span> <span class="org-module-def">Ord</span>(Ordered : COMPARABLE) : ORD <span class="org-keyword">with</span> <span class="org-keyword">type</span> <span class="org-type-def">t</span> = Ordered.t =
<span class="org-keyword">struct</span>
    <span class="org-keyword">type</span> <span class="org-type-def">t</span> = Ordered.t;
    <span class="org-keyword">val</span> <span class="org-variable-name">compare</span> = Ordered.compare;
    <span class="org-keyword">fun</span> <span class="org-function-name">gt</span> (x,y) = compare (x,y) = GREATER;
    <span class="org-keyword">fun</span> <span class="org-function-name">eq</span> (x,y) = compare (x,y) = EQUAL;
    <span class="org-keyword">fun</span> <span class="org-function-name">lt</span> (x,y) = compare (x,y) = LESS;
    <span class="org-keyword">fun</span> <span class="org-function-name">geq</span> (x,y) = not (lt (x,y));
    <span class="org-keyword">fun</span> <span class="org-function-name">leq</span> (x,y) = not (gt (x,y));
    <span class="org-keyword">fun</span> <span class="org-function-name">max</span> (x,y) = <span class="org-keyword">if</span> lt(x,y) <span class="org-keyword">then</span> y <span class="org-keyword">else</span> x;
    <span class="org-keyword">fun</span> <span class="org-function-name">min</span> (x,y) = <span class="org-keyword">if</span> lt(x,y) <span class="org-keyword">then</span> x <span class="org-keyword">else</span> y;
<span class="org-keyword">end</span>;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h-a3213d67-b211-41d1-baea-406a81802cfe" class="outline-2">
<h2 id="h-a3213d67-b211-41d1-baea-406a81802cfe"><span class="section-number-2">6.</span> References</h2>
<div class="outline-text-2" id="text-h-a3213d67-b211-41d1-baea-406a81802cfe">
<ul class="org-ul">
<li>Jrg Nievergelt and Edward M. Reingold,<br>
"Binary search trees of bounded balance".<br>
<i>STOC '72: Proceedings of the fourth annual ACM symposium on Theory of computing</i>,
May 1972, Pages 137&#x2013;142
<a href="https://doi.org/10.1145/800152.804906">https://doi.org/10.1145/800152.804906</a>
<ul class="org-ul">
<li>Cited/blamed as the origin/inspiration for weighted-balanced trees</li>
</ul></li>
<li>Stephen Adams,<br>
"Functional Pearls: Efficient sets &#x2014; a balancing act".<br>
In <i>J. of Func. Progr.</i> <b>3</b> no.4 (1993) pp.553&#x2013;561,
<a href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/functional-pearls-efficient-setsa-balancing-act/0CAA1C189B4F7C15CE9B8C02D0D4B54E">Eprint</a></li>
<li>Yoichi Hirai and Kazuhiko Yamamoto,<br>
"Balancing weight-balanced trees" (PDF).<br>
<i>Journal of Functional Programming</i> <b>21</b> no.3 (2011): 287.
<a href="https://yoichihirai.com/bst.pdf">PDF</a>
<ul class="org-ul">
<li><b>CAUTION:</b> the <code>balanceL</code> and <code>balanceR</code> functions described by
Hirai and Yamamoto are <i>the opposite</i> of their definitions in
Haskell (and we follow the definitions of Haskell).</li>
</ul></li>
<li>Lukas Barth and Dorothea Wagner,<br>
"Engineering Top-Down Weight-Balanced Trees".<br>
<a href="https://arxiv.org/abs/1910.07849">arXiv:1910.07849</a>, 14 pages.</li>
<li>Joachim Breitner, Antal Spector-Zabusky, Yao Li, Christine Rizkallah,
John Wiegley, Stephanie Weirich,<br>
"Ready, Set, Verify! Applying hs-to-coq to real-world Haskell code".<br>
<a href="https://arxiv.org/abs/1803.06960">arXiv:1803.06960</a>, 30 pages.</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="postamble">Last Updated 2023-02-16 Thu 12:12.</p>
</div>
</body>
</html>