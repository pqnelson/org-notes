<!DOCTYPE html>
<html lang="en">
<head>
<!-- 2022-04-09 Sat 11:07 -->
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>MAL - Preliminaries</title>
<meta name="generator" content="Org mode">
<meta name="author" content="Alex Nelson">
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=Spectral&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Merriweather" rel="stylesheet">
<div style="display: none"> \(
\newcommand\D{\mathrm{d}}
\newcommand\E{\mathrm{e}}
\newcommand\I{\mathrm{i}}
\newcommand\bigOh{\mathcal{O}}
\newcommand{\cat}[1]{\mathbf{#1}}
\newcommand\curl{\vec{\nabla}\times}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
\)</div>
<link rel="stylesheet" type="text/css" href="../../css/stylesheet.css" />
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./index.html"> UP </a>
 |
 <a accesskey="H" href="../../index.html"> HOME </a>
</div><div id="content">
<h1 class="title">MAL - Preliminaries</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#h-818893e6-34f9-491b-ad77-e4aa59964583">1. Overview</a></li>
<li><a href="#h-16bc4d6b-f5ee-43a0-9c15-a42a1f701da1">2. Object Model = Tagged Union + Metadata</a>
<ul>
<li><a href="#h-cd871865-9673-46ea-a9c3-0140c43390fe">2.1. Helper Functions</a></li>
<li><a href="#h-e8ff3ec9-4acd-4799-aca4-1e63340eaf54">2.2. Object Model References</a></li>
</ul>
</li>
<li><a href="#h-cbab8801-fa1e-45d9-9a2d-6203c8817a73">3. Atoms</a>
<ul>
<li><a href="#h-187128fd-23ea-456f-8949-e6c6bbb05770">3.1. Primitive Values</a></li>
<li><a href="#h-da478b87-1a15-420d-ad79-de86e7ecbbac">3.2. Strings</a>
<ul>
<li><a href="#h-3a3dc182-6b69-4a88-84b5-3600a4925da7">3.2.1. Constructor</a></li>
<li><a href="#h-a16eefe6-4906-432b-a050-66d299c68e4b">3.2.2. Destructor</a></li>
<li><a href="#h-ec996810-3861-4a40-95ae-0084f00c8a4a">3.2.3. String Equality</a></li>
<li><a href="#h-1cdab51f-7243-4962-9b44-7c5e268a0d39">3.2.4. Computing Hash Code</a></li>
<li><a href="#h-8c4bc7f8-866a-4fec-966f-16e267fb06a0">3.2.5. References</a></li>
</ul>
</li>
<li><a href="#h-b626d54a-265c-4799-b67a-579a51904c11">3.3. Symbols</a>
<ul>
<li><a href="#h-b778912c-1a4b-4a98-b70b-177977d4aec6">3.3.1. Constructor</a></li>
<li><a href="#h-3a0baa71-eaf1-4350-a1b7-1ee865020c9c">3.3.2. Destructor</a></li>
<li><a href="#h-a780efa2-cd22-4bf5-9002-a94aa9cbc745">3.3.3. Hash Code</a></li>
<li><a href="#h-a80606b8-63e7-4729-8331-d497f6ac0d39">3.3.4. Equality</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h-6d571cfb-88b1-450c-bc4b-b2c6664f7dd5">4. Linked Lists</a>
<ul>
<li><a href="#h-c10033e0-c5c3-4676-b0fe-6c320aecb881">4.1. Constructor</a></li>
<li><a href="#h-73c09617-5703-4cf3-9e1b-f375caf4bbfb">4.2. Destructor</a></li>
<li><a href="#h-d23ebef4-d876-4daf-a9ad-9e541ffa0d8d">4.3. Hash Code</a></li>
<li><a href="#h-fa7a330c-701c-40cc-b2f6-1c31ea6a50ac">4.4. Equality</a></li>
</ul>
</li>
<li><a href="#h-29531eeb-d7cf-4663-b39d-a9844134da25">5. Hash Tables</a>
<ul>
<li><a href="#h-59a6d948-fa1d-47a9-8253-2068ba12ea09">5.1. Data Structures</a>
<ul>
<li><a href="#h-ce9ee36b-9dbc-409a-a96e-70412cf03eb2">5.1.1. Entry</a>
<ul>
<li><a href="#h-50fe776c-1679-4f94-860a-21f1265082d0">5.1.1.1. Constructor</a></li>
<li><a href="#h-38bd088b-67ea-4751-838f-dd12c9517088">5.1.1.2. Destructor</a></li>
<li><a href="#h-ca39c5c2-ba5b-4330-aa6f-199c474b5ad6">5.1.1.3. Sorted Insertion</a></li>
</ul>
</li>
<li><a href="#h-a101f2a1-ba47-4d1c-b3c0-c0693c926117">5.1.2. Hash Table</a></li>
</ul>
</li>
<li><a href="#h-95293e2b-c4d0-4a82-8a23-21de97ccc862">5.2. Constructor</a></li>
<li><a href="#h-dd78b2d8-df05-462e-886c-154eeda43b19">5.3. Destructor</a></li>
<li><a href="#h-21bc7c7d-ba68-4268-b524-8a4296e9204f">5.4. Getting a Value for a Key</a></li>
<li><a href="#h-cc6e6ee5-5175-4e6d-afbe-bcc038fc1f26">5.5. Associating a Value for a Key</a>
<ul>
<li><a href="#h-afd9bea1-3433-47c3-b212-8f0c7ee29225">5.5.1. Resizing the Entry Table</a></li>
<li><a href="#h-6028f8e2-fbd4-4c44-902a-ac4f1f638ca9">5.5.2. Transferring Table Contents</a></li>
</ul>
</li>
<li><a href="#h-607cbc47-b766-4a6a-b455-5616d02fc07b">5.6. Removing a key from the Hash Map</a></li>
<li><a href="#h-e5caef6b-d138-4449-bb4d-7c620b2dc2be">5.7. Size of the Hash Map</a></li>
<li><a href="#h-2cee9939-2abd-4aeb-9ae0-cb3c5c4cdc2e">5.8. Hash Code</a></li>
<li><a href="#h-f5f33c7c-cab8-4091-ae36-a13a4fe0d0ac">5.9. Equality of Hash Maps</a></li>
<li><a href="#h-1de2dc41-c561-4de7-8cad-5004ef30e23f">5.10. Hash Table References</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-h-818893e6-34f9-491b-ad77-e4aa59964583" class="outline-2">
<h2 id="h-818893e6-34f9-491b-ad77-e4aa59964583"><span class="section-number-2">1.</span> Overview</h2>
<div class="outline-text-2" id="text-h-818893e6-34f9-491b-ad77-e4aa59964583">
<p>
This contains a discussion of the implementation of data structures for
a Lisp interpreter. The focus will be on the data structures used for
the data types provided by the Lisp interpreter.
</p>
</div>
</div>

<div id="outline-container-h-16bc4d6b-f5ee-43a0-9c15-a42a1f701da1" class="outline-2">
<h2 id="h-16bc4d6b-f5ee-43a0-9c15-a42a1f701da1"><span class="section-number-2">2.</span> Object Model = Tagged Union + Metadata</h2>
<div class="outline-text-2" id="text-h-16bc4d6b-f5ee-43a0-9c15-a42a1f701da1">
<p>
The basic data type for a simple Lisp implementation in C amounts to a
tagged union. Well, we stick the tag plus other metadata in an <b>"Object header"</b>
(borrowing the term from other languages, links below). The idea is we
have a "base class" type implemented as a <code>struct</code>
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.h</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">typedef</span> <span class="org-keyword">enum</span> <span class="org-type">ObjectType</span> {
    <span class="org-comment-delimiter">// </span><span class="org-comment">...</span>
} <span class="org-type">ObjectType</span>;

<span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">Object</span> {
    <span class="org-type">ObjectType</span> <span class="org-variable-name">type</span>;
    <span class="org-comment-delimiter">// </span><span class="org-comment">gc metadata</span>
    <span class="org-comment-delimiter">// </span><span class="org-comment">other metadata</span>
} <span class="org-type">Object</span>;
</pre>
</div>

<p>
Note: we could (should) use bitfields to make the <code>Object</code> 1 word (4
bytes on 32-bit machines, 8 bytes on 64-bit machines). Otherwise, it
could end up multiple words in size (i.e., too big).
</p>

<p>
We then make the first field, in any type in our "object model", an
<code>Object</code> instance:
</p>

<pre class="example" id="ex-obj-header">
struct Example {
    Object header;
    // ...
};
</pre>

<p>
This takes advantage of C standards permitting casting a pointer to a
struct to (and from) a pointer to its first field. In other words, we
get a standards-compliant form of "polymorphism".
</p>
</div>

<div id="outline-container-h-cd871865-9673-46ea-a9c3-0140c43390fe" class="outline-3">
<h3 id="h-cd871865-9673-46ea-a9c3-0140c43390fe"><span class="section-number-3">2.1.</span> Helper Functions</h3>
<div class="outline-text-3" id="text-h-cd871865-9673-46ea-a9c3-0140c43390fe">
<p>
There are a number of functions we'll use for S-expressions generically,
like computing the hash code for an S-expression. (We could, further,
cache this as metadata in the <code>struct Object</code>.)
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.h</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">typedef</span> <span class="org-type">int</span> <span class="org-type">hash_t</span>;

<span class="org-type">hash_t</span> <span class="org-function-name">hashCode</span>(<span class="org-type">Object</span> *<span class="org-variable-name">object</span>);
<span class="org-type">bool</span> <span class="org-function-name">equals</span>(<span class="org-type">Object</span> *<span class="org-variable-name">lhs</span>, <span class="org-type">Object</span> *<span class="org-variable-name">rhs</span>);
</pre>
</div>

<p>
The contracts we demand of these functions:
</p>
<ul class="org-ul">
<li>Let <code>Object *x, *y</code> be non-null.
If <code>equals(x, y)</code> is true, then <code>hashCode(x) == hashCode(y)</code>.
<ul class="org-ul">
<li>We <i>do not</i> require the <a href="https://en.wikipedia.org/wiki/Inverse_(logic)">inverse</a> of this proposition &#x2014; i.e., we do
not require if <code>equals(x, y)</code> is false, then <code>hashCode(x) != hashCode(y)</code>.</li>
</ul></li>
<li>The <code>equals()</code> function is an equivalence relation, so
<ul class="org-ul">
<li>Reflexivity: for any non-null <code>Object *x</code>, we have <code>equals(x, x)</code></li>
<li>Symmetry: for non-null <code>Object *x, *y</code>, if <code>equals(x, y)</code>, then
<code>equals(y, x)</code></li>
<li>Transitivity: for non-null <code>Object *x, *y, *z</code>, if <code>equals(x, y)</code> and
<code>equals(y, z)</code>, then we have <code>equals(x, z)</code></li>
</ul></li>
<li>Further, for any non-null <code>Object *x</code> and <code>Object *null = NULL</code>,
we have <code>equals(x, NULL)</code> and <code>Object(x, null)</code> both return false</li>
<li>We have consistency:
<ul class="org-ul">
<li><code>equals()</code>: for any non-null <code>Object *x, *y</code> we have
<code>equals(x, y)</code> return the same value if we compute it repeatedly
without any other computation in between</li>
<li><code>hashCode()</code>: for any non-null <code>Object *x</code>, we have <code>hashCode(x)</code>
return the same value if called repeatedly and no other computation
occurs in between these calls</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-h-e8ff3ec9-4acd-4799-aca4-1e63340eaf54" class="outline-3">
<h3 id="h-e8ff3ec9-4acd-4799-aca4-1e63340eaf54"><span class="section-number-3">2.2.</span> Object Model References</h3>
<div class="outline-text-3" id="text-h-e8ff3ec9-4acd-4799-aca4-1e63340eaf54">
<ul class="org-ul">
<li><a href="https://shipilev.net/jvm/objects-inside-out/">Java Objects Inside Out</a></li>
<li><a href="https://www.rubyguides.com/2017/04/memory-layout-of-an-object/">Ruby Internals: Exploring the Memory Layout of Ruby Objects</a></li>
<li><a href="https://devblogs.microsoft.com/premier-developer/managed-object-internals-part-4-fields-layout/">CLR (Managed object internals)</a></li>
<li><a href="https://docs.python.org/3/c-api/structures.html">Python Common Object Structures</a></li>
</ul>
</div>
</div>
</div>

<div id="outline-container-h-cbab8801-fa1e-45d9-9a2d-6203c8817a73" class="outline-2">
<h2 id="h-cbab8801-fa1e-45d9-9a2d-6203c8817a73"><span class="section-number-2">3.</span> Atoms</h2>
<div class="outline-text-2" id="text-h-cbab8801-fa1e-45d9-9a2d-6203c8817a73">
<p>
There are two types of atoms: symbols and primitive values. The
primitive values are numbers, strings, booleans, or characters.
Symbols are associated to some value.
</p>
</div>

<div id="outline-container-h-187128fd-23ea-456f-8949-e6c6bbb05770" class="outline-3">
<h3 id="h-187128fd-23ea-456f-8949-e6c6bbb05770"><span class="section-number-3">3.1.</span> Primitive Values</h3>
<div class="outline-text-3" id="text-h-187128fd-23ea-456f-8949-e6c6bbb05770">
<p>
Primitive values would naively be represented by structures like:
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.h</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">struct</span> <span class="org-type">Int</span> {
    <span class="org-type">Object</span> <span class="org-variable-name">header</span>;
    <span class="org-type">int</span> <span class="org-variable-name">value</span>;
};

<span class="org-keyword">struct</span> <span class="org-type">Char</span> {
    <span class="org-type">Object</span> <span class="org-variable-name">header</span>;
    <span class="org-type">char</span> <span class="org-variable-name">codepoint</span>;
};

<span class="org-keyword">struct</span> <span class="org-type">Boolean</span> {
    <span class="org-type">Object</span> <span class="org-variable-name">header</span>;
    <span class="org-type">bool</span> <span class="org-variable-name">value</span>;
};
</pre>
</div>

<p>
These will be two words in size. There are tricks to compactify their
memory usage (NaN boxing, <a href="https://bernsteinbear.com/blog/small-objects/">tagged object pointers</a> since x64 uses 48-bit
addresses giving us 16 bits of metadata).
</p>
</div>
</div>

<div id="outline-container-h-da478b87-1a15-420d-ad79-de86e7ecbbac" class="outline-3">
<h3 id="h-da478b87-1a15-420d-ad79-de86e7ecbbac"><span class="section-number-3">3.2.</span> Strings</h3>
<div class="outline-text-3" id="text-h-da478b87-1a15-420d-ad79-de86e7ecbbac">
<p>
There are several different ways to represent a string. C uses a
null-terminated sequence of characters. Pascal uses length-prefixed
strings &#x2014; by convention, the first <i>k</i> bytes are interpreted as an
integer, encoding the length of the string. C++ (and, I guess, Java)
encodes a string as a record (well, Java uses classes). We'll follow the
structure encoding:
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.h</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">String</span> <span class="org-type">String</span>;

<span class="org-type">String</span>* <span class="org-function-name">string_new</span>(<span class="org-type">char</span> *<span class="org-variable-name">str</span>, <span class="org-type">int</span> <span class="org-variable-name">length</span>);
<span class="org-type">void</span> <span class="org-function-name">string_free</span>(<span class="org-type">String</span> **<span class="org-variable-name">string</span>);
<span class="org-type">bool</span> <span class="org-function-name">string_isEqual</span>(<span class="org-type">String</span> *<span class="org-variable-name">this</span>, <span class="org-type">String</span> *<span class="org-variable-name">other</span>);
<span class="org-type">hash_t</span> <span class="org-function-name">string_hashCode</span>(<span class="org-type">String</span> *<span class="org-variable-name">this</span>);
</pre>
</div>

<p>
The constructor <code>string_new</code> takes an additional parameter, <code>length</code>,
which tells us how many characters to take from the source. The special
value of <code>length &lt; 0</code> will copy until a null character is encountered.
</p>

<p>
The string API can be extended as necessary.
</p>

<p>
The data structure for a string would be implemented as:
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">struct</span> <span class="org-type">String</span> {
    <span class="org-type">Object</span> <span class="org-variable-name">header</span>;
    <span class="org-type">size_t</span> <span class="org-variable-name">length</span>;
    <span class="org-type">char</span> *<span class="org-variable-name">text</span>;
};
</pre>
</div>
</div>

<div id="outline-container-h-3a3dc182-6b69-4a88-84b5-3600a4925da7" class="outline-4">
<h4 id="h-3a3dc182-6b69-4a88-84b5-3600a4925da7"><span class="section-number-4">3.2.1.</span> Constructor</h4>
<div class="outline-text-4" id="text-h-3a3dc182-6b69-4a88-84b5-3600a4925da7">
<p>
The constructor copies the data from the given pointer. There are
basically three key moments to this constructor:
</p>
<ol class="org-ol">
<li>Allocate the memory for the string data structure</li>
<li>Initialize the length (which needs to be computed if the <code>length</code>
parameter is negative)</li>
<li>Allocate and initialize/copy the <code>char[]</code> array of text</li>
</ol>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>

<span class="org-type">String</span>* <span class="org-function-name">string_new</span>(<span class="org-type">char</span> *<span class="org-variable-name">str</span>, <span class="org-type">int</span> <span class="org-variable-name">length</span>) {
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == src) <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;

    <span class="org-type">String</span> *<span class="org-variable-name">string</span> = alloc(<span class="org-keyword">sizeof</span>(*string));
    string-&gt;header.type = TYPE_STRING;

    <span class="org-comment-delimiter">/* </span><span class="org-comment">initialize length</span><span class="org-comment-delimiter"> */</span>
    <span class="org-keyword">if</span> (length &lt; 0) {
        string-&gt;length = strlen(str);
    } <span class="org-keyword">else</span> {
        string-&gt;length = (<span class="org-type">size_t</span>)length;
    }

    <span class="org-comment-delimiter">/* </span><span class="org-comment">allocate and initialize text</span><span class="org-comment-delimiter"> */</span>
    string-&gt;text = alloc_array(string-&gt;length, <span class="org-keyword">sizeof</span>(<span class="org-type">char</span>));
    <span class="org-keyword">if</span> (0 == string-&gt;length) {
        string-&gt;text = <span class="org-constant">NULL</span>;
    } <span class="org-keyword">else</span> {
        memcpy(string-&gt;text, text, string-&gt;length);
    }
    <span class="org-keyword">return</span> string;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-a16eefe6-4906-432b-a050-66d299c68e4b" class="outline-4">
<h4 id="h-a16eefe6-4906-432b-a050-66d299c68e4b"><span class="section-number-4">3.2.2.</span> Destructor</h4>
<div class="outline-text-4" id="text-h-a16eefe6-4906-432b-a050-66d299c68e4b">
<p>
The destructor for a string needs to also free the underlying array of
characters. Then we free the data and metadata for the string object.
Finally we make sure to update the pointer to the string to point to NULL.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-type">void</span> <span class="org-function-name">string_free</span>(<span class="org-type">String</span> **<span class="org-variable-name">this</span>) {
    <span class="org-keyword">if</span> ((<span class="org-constant">NULL</span> == this) || (<span class="org-constant">NULL</span> == *this)) <span class="org-keyword">return</span>;

    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> != (*this)-&gt;text) {
        free((*this)-&gt;text);
    }
    free((*this));
    *this = <span class="org-constant">NULL</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-ec996810-3861-4a40-95ae-0084f00c8a4a" class="outline-4">
<h4 id="h-ec996810-3861-4a40-95ae-0084f00c8a4a"><span class="section-number-4">3.2.3.</span> String Equality</h4>
<div class="outline-text-4" id="text-h-ec996810-3861-4a40-95ae-0084f00c8a4a">
<p>
We can use a couple shortcuts to compute equality. First, if both
arguments are NULL pointers, then return true. But if only one is NULL,
return false.
</p>

<p>
The default case then moves on to non-null pointers. In that case, we
compare the lengths of the strings to rule out unequal strings quickly.
Should the strings have the same length, we compare the contents of the
underlying character array.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-type">bool</span> <span class="org-function-name">string_equals</span>(<span class="org-type">String</span> *<span class="org-variable-name">lhs</span>, <span class="org-type">String</span> *<span class="org-variable-name">rhs</span>) {
    <span class="org-keyword">if</span> (lhs == rhs) <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == lhs) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == rhs) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    <span class="org-keyword">if</span> ((lhs-&gt;length) != (rhs-&gt;length)) <span class="org-keyword">return</span> <span class="org-constant">false</span>;

    <span class="org-keyword">return</span> 0 == memcmp(lhs-&gt;text, rhs-&gt;text, lhs-&gt;length);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-1cdab51f-7243-4962-9b44-7c5e268a0d39" class="outline-4">
<h4 id="h-1cdab51f-7243-4962-9b44-7c5e268a0d39"><span class="section-number-4">3.2.4.</span> Computing Hash Code</h4>
<div class="outline-text-4" id="text-h-1cdab51f-7243-4962-9b44-7c5e268a0d39">
<p>
There are a number of ways to compute the hash code for a string.
Following the generic strategy of computing the hash code for a list
(discussed below), treating the String as a list of characters.
(If we wanted to borrow, e.g., Fowler&#x2013;Noll&#x2013;Vo hashing, we would
replace <code>h*31</code> by <code>h*FNV_prime</code>, and the addition by an XOR. The initial
value of the hash would be the <code>FNV_offset_basis</code>.)
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-type">hash_t</span> <span class="org-function-name">string_hashCode</span>(<span class="org-type">String</span> *<span class="org-variable-name">string</span>) {
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == string) <span class="org-keyword">return</span> 0;
    <span class="org-keyword">if</span> (0 == string-&gt;length) <span class="org-keyword">return</span> 0;
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == string-&gt;text) <span class="org-keyword">return</span> 0;
    <span class="org-type">hash_t</span> <span class="org-variable-name">h</span> = 0;
    <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; string-&gt;length; i++) {
        h = h*31 + (<span class="org-type">hash_t</span>)(string-&gt;text[i]);
    }
    <span class="org-keyword">return</span> h;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h-8c4bc7f8-866a-4fec-966f-16e267fb06a0" class="outline-4">
<h4 id="h-8c4bc7f8-866a-4fec-966f-16e267fb06a0"><span class="section-number-4">3.2.5.</span> References</h4>
<div class="outline-text-4" id="text-h-8c4bc7f8-866a-4fec-966f-16e267fb06a0">
<ul class="org-ul">
<li>Java's <code>String.java</code> (<a href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/classes/java/lang/String.java">jdk8-b120</a>, <a href="https://github.com/openjdk/jdk/blob/jdk7-b24/jdk/src/share/classes/java/lang/String.java">jdk7-b24</a>)</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-h-b626d54a-265c-4799-b67a-579a51904c11" class="outline-3">
<h3 id="h-b626d54a-265c-4799-b67a-579a51904c11"><span class="section-number-3">3.3.</span> Symbols</h3>
<div class="outline-text-3" id="text-h-b626d54a-265c-4799-b67a-579a51904c11">
<p>
We intern symbols to make at most one object which corresponds with a
symbol name. This could be done using a Hash Table, a binary tree, or
some other data structure.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.h</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">Symbol</span> <span class="org-type">Symbol</span>;

<span class="org-type">Symbol</span>* <span class="org-function-name">intern</span>(<span class="org-type">char</span> *<span class="org-variable-name">name</span>);
<span class="org-type">void</span> <span class="org-function-name">symbol_free</span>(<span class="org-type">Symbol</span> **<span class="org-variable-name">symbol</span>);
<span class="org-type">hash_t</span> <span class="org-function-name">symbol_hashCode</span>(<span class="org-type">Symbol</span> *<span class="org-variable-name">this</span>);
</pre>
</div>

<p>
We make public the <code>symbol_free()</code> function, though we may want to hide
it, and make some method to register it with the garbage collector
hidden from the user.
</p>

<p>
Again, we are using opaque pointers (since it's good style):
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>

<span class="org-keyword">struct</span> <span class="org-type">Symbol</span> {
    <span class="org-type">Object</span> <span class="org-variable-name">header</span>;
    <span class="org-type">String</span> *<span class="org-variable-name">name</span>;
};
</pre>
</div>

<p>
The contract is, for any non-empty strings <code>x</code> and <code>y</code> such that they
are equal (in the sense that <code>0 == strcmp(x, y)</code>),
then we have <code>intern(x) == intern(y)</code>
and specifically
<code>intern(x) != NULL</code>.
</p>
</div>

<div id="outline-container-h-b778912c-1a4b-4a98-b70b-177977d4aec6" class="outline-4">
<h4 id="h-b778912c-1a4b-4a98-b70b-177977d4aec6"><span class="section-number-4">3.3.1.</span> Constructor</h4>
<div class="outline-text-4" id="text-h-b778912c-1a4b-4a98-b70b-177977d4aec6">
<p>
The trick to this is we will use a Hash Table to lookup the symbol with
a given name. If it exists, we return that; otherwise, we create a new
Symbol object, save it in the Hash Table, and return the Symbol object.
</p>

<p>
One word of warning: if we extend our interpreter to include
multithreading, then we must make sure our HashMap is concurrent.
Otherwise, we may end up with race conditions regarding the <code>symbol_table</code>.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-keyword">static</span> <span class="org-type">HashMap</span> *<span class="org-variable-name">symbol_table</span> = <span class="org-constant">NULL</span>;

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">init_symbol_table</span>() {
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == symbol_table) {
        symbol_table = hashmap_new();
    }
}

<span class="org-keyword">static</span> <span class="org-type">Symbol</span>* <span class="org-function-name">symbol_new</span>(<span class="org-type">String</span> *<span class="org-variable-name">name</span>) {
    <span class="org-type">Symbol</span> *<span class="org-variable-name">symbol</span> = alloc(<span class="org-keyword">sizeof</span>(*symbol));
    symbol-&gt;header.type = TYPE_SYMBOL;
    symbol-&gt;name = name;
    <span class="org-keyword">return</span> symbol;
}

<span class="org-type">Symbol</span>* <span class="org-function-name">intern</span>(<span class="org-type">char</span> *<span class="org-variable-name">name</span>) {
    init_symbol_table();
    <span class="org-type">String</span> *<span class="org-variable-name">key</span> = string_new(name, -1);
    <span class="org-type">Symbol</span> *<span class="org-variable-name">symbol</span> = hashmap_get(&amp;symbol_table, key);

    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == symbol) {
        symbol = symbol_name(key);
        hashmap_put(&amp;symbol_table, key, symbol);
    } <span class="org-keyword">else</span> {
        <span class="org-comment-delimiter">// </span><span class="org-comment">cache hit</span>
        string_free(&amp;key);
    }
    <span class="org-keyword">return</span> symbol;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-3a0baa71-eaf1-4350-a1b7-1ee865020c9c" class="outline-4">
<h4 id="h-3a0baa71-eaf1-4350-a1b7-1ee865020c9c"><span class="section-number-4">3.3.2.</span> Destructor</h4>
<div class="outline-text-4" id="text-h-3a0baa71-eaf1-4350-a1b7-1ee865020c9c">
<p>
I'm not sure I need this, exactly. But I'll vacate the symbol table, and
delete the symbol and its underlying string.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-type">void</span> <span class="org-function-name">symbol_free</span>(<span class="org-type">Symbol</span> **<span class="org-variable-name">symbol</span>) {
    <span class="org-keyword">if</span> ((<span class="org-constant">NULL</span> == symbol) || (<span class="org-constant">NULL</span> == *symbol)) <span class="org-keyword">return</span>;
    hashmap_remove(symbol_table, (*symbol)-&gt;name);
    string-&gt;free(&amp;((*symbol)-&gt;name));
    free(*symbol);
    (*symbol) = <span class="org-constant">NULL</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-a780efa2-cd22-4bf5-9002-a94aa9cbc745" class="outline-4">
<h4 id="h-a780efa2-cd22-4bf5-9002-a94aa9cbc745"><span class="section-number-4">3.3.3.</span> Hash Code</h4>
<div class="outline-text-4" id="text-h-a780efa2-cd22-4bf5-9002-a94aa9cbc745">
<p>
The hash code for a symbol amounts to computing the hash code for the
associated string.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-type">hash_t</span> <span class="org-function-name">symbol_hashCode</span>(<span class="org-type">Symbol</span> *<span class="org-variable-name">symbol</span>) {
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == symbol) <span class="org-keyword">return</span> 0;
    <span class="org-keyword">return</span> string_hashCode(symbol-&gt;name);
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-a80606b8-63e7-4729-8331-d497f6ac0d39" class="outline-4">
<h4 id="h-a80606b8-63e7-4729-8331-d497f6ac0d39"><span class="section-number-4">3.3.4.</span> Equality</h4>
<div class="outline-text-4" id="text-h-a80606b8-63e7-4729-8331-d497f6ac0d39">
<p>
Since we're interning symbols, we could use pointer equality. But
ostensibly we'll extend symbols to a multithreaded environment&#x2026;so we
could end up in a tricky situation where pointer comparison does not
work.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-type">bool</span> <span class="org-function-name">symbol_equals</span>(<span class="org-type">Symbol</span> *<span class="org-variable-name">lhs</span>, <span class="org-type">Symbol</span> *<span class="org-variable-name">rhs</span>) {
    <span class="org-keyword">if</span> (lhs == rhs) <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == lhs) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == rhs) <span class="org-keyword">return</span> <span class="org-constant">true</span>;

<span class="org-preprocessor">#if</span> <span class="org-preprocessor">defined</span>(MULTITHREADED_PARANOID)
<span class="org-preprocessor">#if</span> MULTITHREADED_PARANOID
    <span class="org-keyword">return</span> string_equals(lhs-&gt;name, rhs-&gt;name);
<span class="org-preprocessor">#endif</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">MULTITHREADED_PARANOID</span><span class="org-comment-delimiter"> */</span>
<span class="org-preprocessor">#else</span>
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
<span class="org-preprocessor">#endif</span> <span class="org-comment-delimiter">/* </span><span class="org-comment">defined(MULTITHREADED_PARANOID)</span><span class="org-comment-delimiter"> */</span>
}
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-h-6d571cfb-88b1-450c-bc4b-b2c6664f7dd5" class="outline-2">
<h2 id="h-6d571cfb-88b1-450c-bc4b-b2c6664f7dd5"><span class="section-number-2">4.</span> Linked Lists</h2>
<div class="outline-text-2" id="text-h-6d571cfb-88b1-450c-bc4b-b2c6664f7dd5">
<p>
Also called "cons cells", linked lists are what you'd expect. They're
the only data type with pointers, so far.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.h</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">Cons</span> <span class="org-type">Cons</span>;

<span class="org-type">Cons</span>* <span class="org-function-name">cons_new</span>(<span class="org-type">Object</span> *<span class="org-variable-name">car</span>, <span class="org-type">Object</span> *<span class="org-variable-name">cdr</span>);
<span class="org-type">void</span> <span class="org-function-name">cons_free</span>(<span class="org-type">Cons</span> **<span class="org-variable-name">this</span>);
<span class="org-type">hash_t</span> <span class="org-function-name">cons_hashCode</span>(<span class="org-type">Cons</span> *<span class="org-variable-name">this</span>);
</pre>
</div>

<p>
The opaque pointer refers to:
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">struct</span> <span class="org-type">Cons</span> {
    <span class="org-type">Object</span> <span class="org-variable-name">header</span>;
    <span class="org-type">Object</span> **<span class="org-variable-name">car</span>;
    <span class="org-type">Object</span> **<span class="org-variable-name">cdr</span>;
};
<span class="org-preprocessor">#define</span> <span class="org-function-name">safe_car</span>(<span class="org-variable-name">cell</span>) (<span class="org-constant">NULL</span> == (cell)-&gt;car ? <span class="org-constant">NULL</span> : *((cell)-&gt;car))
<span class="org-preprocessor">#define</span> <span class="org-function-name">safe_cdr</span>(<span class="org-variable-name">cell</span>) (<span class="org-constant">NULL</span> == (cell)-&gt;cdr ? <span class="org-constant">NULL</span> : *((cell)-&gt;cdr))
</pre>
</div>

<p>
Why use double pointers? Well, really, we should think of
<code>typedef struct Object* ObjectRef</code>, and a cons-cell consists of a
pointer to an <code>ObjectRef</code>. When we free the memory for the object
pointed by the <code>ObjectRef</code>, we update the <code>ObjectRef</code> to be null. This
requires using double pointers for this update to persist.
</p>
</div>

<div id="outline-container-h-c10033e0-c5c3-4676-b0fe-6c320aecb881" class="outline-3">
<h3 id="h-c10033e0-c5c3-4676-b0fe-6c320aecb881"><span class="section-number-3">4.1.</span> Constructor</h3>
<div class="outline-text-3" id="text-h-c10033e0-c5c3-4676-b0fe-6c320aecb881">
<p>
The constructor works as we would expect: allocate the memory for the
header and addresses. If one of the arguments is NULL, then its double
pointer will point to NULL.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">Cons</span>* <span class="org-function-name">cons_new</span>(<span class="org-type">Object</span> *<span class="org-variable-name">car</span>, <span class="org-type">Object</span> *<span class="org-variable-name">cdr</span>) {
    <span class="org-type">Cons</span> *<span class="org-variable-name">cell</span> = alloc(<span class="org-keyword">sizeof</span>(*cell));
    cell-&gt;header.type = TYPE_CONS;
    cell-&gt;car = (<span class="org-constant">NULL</span> == car) ? <span class="org-constant">NULL</span> : &amp;car;
    cell-&gt;cdr = (<span class="org-constant">NULL</span> == cdr) ? <span class="org-constant">NULL</span> : &amp;cdr;
    <span class="org-keyword">return</span> cell;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-73c09617-5703-4cf3-9e1b-f375caf4bbfb" class="outline-3">
<h3 id="h-73c09617-5703-4cf3-9e1b-f375caf4bbfb"><span class="section-number-3">4.2.</span> Destructor</h3>
<div class="outline-text-3" id="text-h-73c09617-5703-4cf3-9e1b-f375caf4bbfb">
<p>
This requires a bit more care. We'll iterate through the list,
recursively freeing the car and cdr, before finally freeing the wrapper
and metadata for the Cons cell itself.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">void</span> <span class="org-function-name">cons_free</span>(<span class="org-type">Cons</span> **<span class="org-variable-name">this</span>) {
    <span class="org-keyword">if</span> ((<span class="org-constant">NULL</span> == this) || (<span class="org-constant">NULL</span> == *this)) <span class="org-keyword">return</span>;
    obj_free((*this)-&gt;car);
    <span class="org-comment-delimiter">//</span><span class="org-comment">@ assert (\null == \old(*this)-&gt;car) || (\null == *((*this)-&gt;car));</span>
    obj_free((*this)-&gt;cdr);
    <span class="org-comment-delimiter">//</span><span class="org-comment">@ assert (\null == \old(*this)-&gt;cdr) || (\null == *((*this)-&gt;cdr));</span>
    free(*this);
    (*this) = <span class="org-constant">NULL</span>;
}
</pre>
</div>
</div>
</div>
<div id="outline-container-h-d23ebef4-d876-4daf-a9ad-9e541ffa0d8d" class="outline-3">
<h3 id="h-d23ebef4-d876-4daf-a9ad-9e541ffa0d8d"><span class="section-number-3">4.3.</span> Hash Code</h3>
<div class="outline-text-3" id="text-h-d23ebef4-d876-4daf-a9ad-9e541ffa0d8d">
<p>
The basic computation amounts to
</p>

<pre class="example" id="ex-list-hash">
hash_t list_hashCode(List *this) {
    hash_t hashCode = 1;
    for (Elt e : this)
        hashCode = 31*hashCode + ((NULL == e) ? 0 : hashCode(e));
    return hashCode;
}
</pre>

<p>
The actual source  code implementation needs to handle the special case
where <code>cell == nil</code>, when it should be zero.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">hash_t</span> <span class="org-function-name">cons_hashCode</span>(<span class="org-type">Cons</span> *<span class="org-variable-name">cell</span>) {
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == cell) <span class="org-keyword">return</span> 0;

    <span class="org-type">hash_t</span> <span class="org-variable-name">h</span> = 1;
    <span class="org-type">Object</span> *<span class="org-variable-name">car</span> = safe_car(cell);
    <span class="org-type">Object</span> *<span class="org-variable-name">cdr</span> = safe_cdr(cell);

    <span class="org-keyword">if</span> ((<span class="org-constant">NULL</span> == car) &amp;&amp; (<span class="org-constant">NULL</span> == cdr)) {
        h = 0;
    } <span class="org-keyword">else</span> {
        h = 31*h + hashCode(car);
        h = 31*h + hashCode(cdr);
    }
    <span class="org-keyword">return</span> h;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-fa7a330c-701c-40cc-b2f6-1c31ea6a50ac" class="outline-3">
<h3 id="h-fa7a330c-701c-40cc-b2f6-1c31ea6a50ac"><span class="section-number-3">4.4.</span> Equality</h3>
<div class="outline-text-3" id="text-h-fa7a330c-701c-40cc-b2f6-1c31ea6a50ac">
<p>
We test for equality by checking the car of the left-hand side equals
the car of the right-hand side, and the cdr of both sides are equal.
Component-wise equality, in other words.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">bool</span> <span class="org-function-name">cons_equals</span>(<span class="org-type">Cons</span> *<span class="org-variable-name">lhs</span>, <span class="org-type">Cons</span> *<span class="org-variable-name">rhs</span>) {
    <span class="org-keyword">if</span> (lhs == rhs) <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == lhs) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == rhs) <span class="org-keyword">return</span> <span class="org-constant">false</span>;

    <span class="org-keyword">if</span> (equals(safe_car(lhs), safe_car(rhs))) {
        <span class="org-keyword">return</span> equals(safe_cdr(lhs), safe_cdr(rhs));
    }
    <span class="org-keyword">return</span> <span class="org-constant">false</span>;
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h-29531eeb-d7cf-4663-b39d-a9844134da25" class="outline-2">
<h2 id="h-29531eeb-d7cf-4663-b39d-a9844134da25"><span class="section-number-2">5.</span> Hash Tables</h2>
<div class="outline-text-2" id="text-h-29531eeb-d7cf-4663-b39d-a9844134da25">
<p>
There are many different implementations. Basically the difference boils
down to using "chaining" (the buckets are a linked list &#x2014; Java did
this prior to version 8) or <a href="https://en.wikipedia.org/wiki/Open_addressing">"open addressing"</a>.
</p>

<p>
Some implementations don't require hash tables, but there are two
reasons I'm including them. The first, Common Lisp provides them. The
second, we can use them as the data structure for the environment
(dictionary binding symbols to their values).
</p>

<p>
Arguably, we could implement hash tables using cons-cells and atomic
types. In fact, that's what most Common Lisp implementations <i>do</i>.
</p>

<p>
We will implement a Hash Table in C.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.h</span><span class="org-comment-delimiter"> */</span>
<span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">HashMap</span> <span class="org-type">HashMap</span>;

<span class="org-type">HashMap</span>* <span class="org-function-name">hashmap_new</span>();
<span class="org-type">void</span> <span class="org-function-name">hashmap_free</span>(<span class="org-type">HashMap</span> **<span class="org-variable-name">this</span>);
<span class="org-type">hash_t</span> <span class="org-function-name">hashmap_hashCode</span>(<span class="org-type">HashMap</span> *<span class="org-variable-name">this</span>);
<span class="org-type">bool</span> <span class="org-function-name">hashmap_equals</span>(<span class="org-type">HashMap</span> **<span class="org-variable-name">lhs</span>, <span class="org-type">HashMap</span> **<span class="org-variable-name">rhs</span>);
<span class="org-type">Object</span>* <span class="org-function-name">hashmap_get</span>(<span class="org-type">HashMap</span> *<span class="org-variable-name">this</span>, <span class="org-type">Object</span> *<span class="org-variable-name">key</span>);
<span class="org-type">Object</span>* <span class="org-function-name">hashmap_put</span>(<span class="org-type">HashMap</span> *<span class="org-variable-name">this</span>, <span class="org-type">Object</span> *<span class="org-variable-name">key</span>, <span class="org-type">Object</span> *<span class="org-variable-name">value</span>);
<span class="org-type">void</span> <span class="org-function-name">hashmap_remove</span>(<span class="org-type">HashMap</span> *<span class="org-variable-name">this</span>, <span class="org-type">Object</span> *<span class="org-variable-name">key</span>);
<span class="org-type">size_t</span> <span class="org-function-name">hashmap_size</span>(<span class="org-type">HashMap</span> *<span class="org-variable-name">this</span>);
</pre>
</div>

<p>
Arguably, there may be other functions to consider implementing.
</p>
</div>

<div id="outline-container-h-59a6d948-fa1d-47a9-8253-2068ba12ea09" class="outline-3">
<h3 id="h-59a6d948-fa1d-47a9-8253-2068ba12ea09"><span class="section-number-3">5.1.</span> Data Structures</h3>
<div class="outline-text-3" id="text-h-59a6d948-fa1d-47a9-8253-2068ba12ea09">
<p>
We will use simple chaining. The idea is to use an array of buckets (a
bucket is a linked list of "Entries" &#x2014; key-value pairs plus some extra metadata),
associating a key-value pair to exactly one bucket. When there are too
many entries, we increase the number of buckets, then rebalance the
entries.
</p>
</div>

<div id="outline-container-h-ce9ee36b-9dbc-409a-a96e-70412cf03eb2" class="outline-4">
<h4 id="h-ce9ee36b-9dbc-409a-a96e-70412cf03eb2"><span class="section-number-4">5.1.1.</span> Entry</h4>
<div class="outline-text-4" id="text-h-ce9ee36b-9dbc-409a-a96e-70412cf03eb2">
<p>
An entry is a data structure with some extra metadata, namely the hash
code for the key (so we compute it once).
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>

<span class="org-keyword">typedef</span> <span class="org-keyword">struct</span> <span class="org-type">Entry</span> {
    <span class="org-type">Object</span> *<span class="org-variable-name">key</span>;
    <span class="org-type">Object</span> *<span class="org-variable-name">value</span>;
    <span class="org-type">hash_t</span> <span class="org-variable-name">hash</span>;
    <span class="org-keyword">struct</span> <span class="org-type">Entry</span> *<span class="org-variable-name">next</span>;
} <span class="org-type">Entry</span>;
</pre>
</div>
</div>

<div id="outline-container-h-50fe776c-1679-4f94-860a-21f1265082d0" class="outline-5">
<h5 id="h-50fe776c-1679-4f94-860a-21f1265082d0"><span class="section-number-5">5.1.1.1.</span> Constructor</h5>
<div class="outline-text-5" id="text-h-50fe776c-1679-4f94-860a-21f1265082d0">
<p>
We have the usual boiler plate code for it, namely a constructor and
destructor.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>

<span class="org-type">Entry</span>* <span class="org-function-name">entry_new</span>(<span class="org-type">Object</span> *<span class="org-variable-name">key</span>, <span class="org-type">Object</span> *<span class="org-variable-name">value</span>, <span class="org-type">hash_t</span> <span class="org-variable-name">hash</span>) {
    <span class="org-type">Entry</span> *<span class="org-variable-name">entry</span> = alloc(<span class="org-keyword">sizeof</span>(*entry));
    entry-&gt;key = key;
    entry-&gt;value = value;
    entry-&gt;next = <span class="org-constant">NULL</span>;
    entry-&gt;hash = hash;
    <span class="org-keyword">return</span> entry;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-38bd088b-67ea-4751-838f-dd12c9517088" class="outline-5">
<h5 id="h-38bd088b-67ea-4751-838f-dd12c9517088"><span class="section-number-5">5.1.1.2.</span> Destructor</h5>
<div class="outline-text-5" id="text-h-38bd088b-67ea-4751-838f-dd12c9517088">
<p>
The only nuance to the Entry data structure is, unlike a Cons cell, its
destructor will not recursively destroy its next Entry.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>

<span class="org-type">void</span> <span class="org-function-name">entry_free</span>(<span class="org-type">Entry</span> **<span class="org-variable-name">entry</span>) {
    <span class="org-keyword">if</span> ((<span class="org-constant">NULL</span> == entry) || (<span class="org-constant">NULL</span> == *entry)) <span class="org-keyword">return</span>;

    free(*entry);
    (*entry) = <span class="org-constant">NULL</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-ca39c5c2-ba5b-4330-aa6f-199c474b5ad6" class="outline-5">
<h5 id="h-ca39c5c2-ba5b-4330-aa6f-199c474b5ad6"><span class="section-number-5">5.1.1.3.</span> Sorted Insertion</h5>
<div class="outline-text-5" id="text-h-ca39c5c2-ba5b-4330-aa6f-199c474b5ad6">
<p>
Given a pointer to (a pointer to) an entry, and an entry we wish to
insert into the linked list, insert the new entry in a manner that the
linked list is sorted by hash code.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>
<span class="org-type">void</span> <span class="org-function-name">entry_insert</span>(<span class="org-type">Entry</span> **<span class="org-variable-name">list</span>, <span class="org-type">Entry</span> *<span class="org-variable-name">entry</span>) {
    assert(<span class="org-constant">NULL</span> != entry);
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == list) <span class="org-keyword">return</span>;
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == *list) {
        (*list) = entry;
        entry-&gt;next = <span class="org-constant">NULL</span>;
        <span class="org-keyword">return</span>;
    } <span class="org-keyword">else</span> <span class="org-keyword">if</span> ((entry-&gt;hash) &lt;= ((*list)-&gt;hash)) {
        entry-&gt;next = (*list);
        (*list) = entry;
        <span class="org-keyword">return</span>;
    } <span class="org-keyword">else</span> {
        assert((entry-&gt;hash) &gt; ((*list)-&gt;hash));
        <span class="org-type">Entry</span> *<span class="org-variable-name">prev</span> = *item;
        <span class="org-type">Entry</span> *<span class="org-variable-name">e</span> = <span class="org-constant">NULL</span>;
        <span class="org-keyword">for</span> (e = prev-&gt;next; <span class="org-constant">NULL</span> != *e; e = e-&gt;next) {
            <span class="org-comment-delimiter">// </span><span class="org-comment">if (prev &lt; entry &lt;= e)</span>
            <span class="org-keyword">if</span> (((prev-&gt;hash) &lt; (entry-&gt;hash)) &amp;&amp;
                ((entry-&gt;hash) &lt;= (e-&gt;hash))) {
                prev-&gt;next = entry;
                entry-&gt;next = e;
                <span class="org-keyword">return</span>;
            }
            prev = e;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">append at the end of the linked list</span>
        assert(<span class="org-constant">NULL</span> == e);
        assert(<span class="org-constant">NULL</span> != prev);
        prev-&gt;next = entry;
        entry-&gt;next = <span class="org-constant">NULL</span>;
    }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h-a101f2a1-ba47-4d1c-b3c0-c0693c926117" class="outline-4">
<h4 id="h-a101f2a1-ba47-4d1c-b3c0-c0693c926117"><span class="section-number-4">5.1.2.</span> Hash Table</h4>
<div class="outline-text-4" id="text-h-a101f2a1-ba47-4d1c-b3c0-c0693c926117">
<p>
The Hash Map consists of an array of Entry pointers. We track how many
entries belong to the hash map in its <code>size</code> parameter; and when it
exceeds the <code>capacity</code>, we grow the number of buckets and rebalance.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>

<span class="org-keyword">struct</span> <span class="org-type">HashMap</span> {
    <span class="org-type">Object</span> <span class="org-variable-name">header</span>;
    <span class="org-type">Entry</span> **<span class="org-variable-name">table</span>;
    <span class="org-type">size_t</span> <span class="org-variable-name">capacity</span>;
    <span class="org-type">size_t</span> <span class="org-variable-name">size</span>;
};
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h-95293e2b-c4d0-4a82-8a23-21de97ccc862" class="outline-3">
<h3 id="h-95293e2b-c4d0-4a82-8a23-21de97ccc862"><span class="section-number-3">5.2.</span> Constructor</h3>
<div class="outline-text-3" id="text-h-95293e2b-c4d0-4a82-8a23-21de97ccc862">
<p>
The constructor expects no parameters. The default capacity for a hash
map would be 16, its initial size 0.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">INITIAL_HASH_MAP_CAPACITY</span> 16 <span class="org-comment-delimiter">/* </span><span class="org-comment">must be power of 2</span><span class="org-comment-delimiter"> */</span>

<span class="org-type">HashMap</span>* <span class="org-function-name">hashmap_new</span>() {
    <span class="org-type">HashMap</span> *<span class="org-variable-name">map</span> = alloc(<span class="org-keyword">sizeof</span>(*map));
    map-&gt;header.type = TYPE_HASH_MAP;
    map-&gt;capacity = INITIAL_HASH_MAP_CAPACITY;
    map-&gt;size = 0;
    map-&gt;table = alloc_array(<span class="org-keyword">sizeof</span>(<span class="org-keyword">struct</span> <span class="org-type">Entry</span>*), map-&gt;capacity);
    <span class="org-keyword">return</span> map;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-dd78b2d8-df05-462e-886c-154eeda43b19" class="outline-3">
<h3 id="h-dd78b2d8-df05-462e-886c-154eeda43b19"><span class="section-number-3">5.3.</span> Destructor</h3>
<div class="outline-text-3" id="text-h-dd78b2d8-df05-462e-886c-154eeda43b19">
<p>
When we destroy a HashMap object, we also have to iteratively destroy
the table entries.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>

<span class="org-type">void</span> <span class="org-function-name">hashmap_free</span>(<span class="org-type">HashMap</span> **<span class="org-variable-name">this</span>) {
    <span class="org-keyword">if</span> ((<span class="org-constant">NULL</span> == this) || (<span class="org-constant">NULL</span> == *this)) <span class="org-keyword">return</span>;

    <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">row</span> = 0; row &lt; (*this)-&gt;capacity; row++) {
        <span class="org-type">Entry</span> *<span class="org-variable-name">iter</span> = (*this)-&gt;table[row];
        <span class="org-keyword">while</span> (<span class="org-constant">NULL</span> != iter) {
            <span class="org-type">Entry</span> *<span class="org-variable-name">next</span> = iter-&gt;next;
            entry_free(iter);
            iter = next;
        }
    }

    free(*this);
    (*this) = <span class="org-constant">NULL</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-21bc7c7d-ba68-4268-b524-8a4296e9204f" class="outline-3">
<h3 id="h-21bc7c7d-ba68-4268-b524-8a4296e9204f"><span class="section-number-3">5.4.</span> Getting a Value for a Key</h3>
<div class="outline-text-3" id="text-h-21bc7c7d-ba68-4268-b524-8a4296e9204f">
<p>
We then need to isolate a helper function to get the index for a given
hash code. Since our code makes sure there are 2<sup>n</sup> buckets in the table,
we can use the fact <code>hash % length == hash &amp; (length - 1)</code>. Using
bitwise-and is faster than the modulo operator.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>

<span class="org-keyword">static</span> <span class="org-type">size_t</span> <span class="org-function-name">indexFor</span>(<span class="org-type">hash_t</span> <span class="org-variable-name">hash</span>, <span class="org-type">size_t</span> <span class="org-variable-name">length</span>) {
    <span class="org-keyword">return</span> hash &amp; (length - 1);
}
</pre>
</div>

<p>
Now the process for obtaining the value for a given key is quite
straightforward traversing the linked list ("bucket") selected by that
index, and when finding that key, returning the associated value:
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>

<span class="org-type">Object</span>* <span class="org-function-name">hashmap_get</span>(<span class="org-type">HashMap</span> *<span class="org-variable-name">this</span>, <span class="org-type">Object</span> *<span class="org-variable-name">key</span>) {
    assert (<span class="org-constant">NULL</span> != this);

    <span class="org-type">hash_t</span> <span class="org-variable-name">h</span> = hashCode(key);
    <span class="org-type">size_t</span> <span class="org-variable-name">index</span> = indexFor(h, this-&gt;capacity);
    <span class="org-keyword">for</span> (<span class="org-type">Entry</span> *<span class="org-variable-name">e</span> = this-&gt;table[index]; e != <span class="org-constant">NULL</span>; e = e-&gt;next) {
        <span class="org-keyword">if</span> (equals(key, e-&gt;key)) {
            <span class="org-keyword">return</span> e-&gt;value;
        }
    }
    <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-cc6e6ee5-5175-4e6d-afbe-bcc038fc1f26" class="outline-3">
<h3 id="h-cc6e6ee5-5175-4e6d-afbe-bcc038fc1f26"><span class="section-number-3">5.5.</span> Associating a Value for a Key</h3>
<div class="outline-text-3" id="text-h-cc6e6ee5-5175-4e6d-afbe-bcc038fc1f26">
<p>
We associate a value to a key in a given hash map by finding the bucket
associated for the hash code for that key. First, we try finding the key
in that bucket of entries by simple traversal. If we're lucky, it's
already associated with a value. In that case, we just update the entry
to point to the new value, and return the old value.
</p>

<p>
But if that bucket has not been started (so it's a null pointer) <i>or</i> if
the bucket does not contain the key, then we create a new entry, and
prepend it to that row of the table. Since no value is associated to the
key, we return a null pointer.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>

<span class="org-preprocessor">#define</span> <span class="org-variable-name">CAPACITY_FACTOR</span> 0.75

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">resize</span>(<span class="org-type">HashMap</span> *<span class="org-variable-name">this</span>, <span class="org-type">size_t</span> <span class="org-variable-name">new_capacity</span>);

<span class="org-type">Object</span>* <span class="org-function-name">hashmap_put</span>(<span class="org-type">HashMap</span> *<span class="org-variable-name">this</span>, <span class="org-type">Object</span> *<span class="org-variable-name">key</span>, <span class="org-type">Object</span> *<span class="org-variable-name">value</span>) {
    assert(<span class="org-constant">NULL</span> != this);

    <span class="org-type">hash_t</span> <span class="org-variable-name">h</span> = hashCode(key);
    <span class="org-type">size_t</span> <span class="org-variable-name">index</span> = indexFor(h, this-&gt;capacity);
    <span class="org-type">Entry</span> *<span class="org-variable-name">entry</span> = this-&gt;table[index];
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> != entry) {
        <span class="org-comment-delimiter">// </span><span class="org-comment">try updating the value associated to key, if key is present</span>
        <span class="org-type">Entry</span> *<span class="org-variable-name">e</span> = entry;
        <span class="org-keyword">while</span> (e != <span class="org-constant">NULL</span>) {
            <span class="org-keyword">if</span> ((e-&gt;hash == h) &amp;&amp; equals(keys, e-&gt;key)) {
                <span class="org-type">Object</span> *<span class="org-variable-name">old_val</span> = e-&gt;value;
                e-&gt;value = value;
                <span class="org-keyword">return</span> old_val;
            }
            e = e-&gt;next;
        }
        <span class="org-comment-delimiter">// </span><span class="org-comment">fall-through: no key associated with that value, then prepend entry</span>
    }
    <span class="org-comment-delimiter">// </span><span class="org-comment">key is not present, so add entry</span>
    <span class="org-type">Entry</span> *<span class="org-variable-name">new_entry</span> = entry_new(key, value, h);
    <span class="org-comment-delimiter">// </span><span class="org-comment">entry_insert(&amp;(this-&gt;table[index]), new_entry);</span>
    new_entry-&gt;next = this-&gt;table[index];
    this-&gt;table[index] = new_entry;
    this-&gt;size++;

    <span class="org-keyword">if</span> ((this-&gt;size) &gt;= (<span class="org-type">size_t</span>)((this-&gt;capacity)*CAPACITY_FACTOR)) {
        resize(this, 2*(this-&gt;capacity));
    }
    <span class="org-keyword">return</span> <span class="org-constant">NULL</span>;
}
</pre>
</div>
</div>

<div id="outline-container-h-afd9bea1-3433-47c3-b212-8f0c7ee29225" class="outline-4">
<h4 id="h-afd9bea1-3433-47c3-b212-8f0c7ee29225"><span class="section-number-4">5.5.1.</span> Resizing the Entry Table</h4>
<div class="outline-text-4" id="text-h-afd9bea1-3433-47c3-b212-8f0c7ee29225">
<p>
The basic idea is to resize the hash map's underlying table by creating
a new array of entry pointers, then transfer the contents of the array,
free the old array of pointers (just the array). We'll also need to
update the table pointer, and the hash map's capacity.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">transfer</span>(<span class="org-type">Entry</span> **<span class="org-variable-name">old_table</span>, <span class="org-type">Entry</span> **<span class="org-variable-name">new_table</span>,
                     <span class="org-type">size_t</span> <span class="org-variable-name">length</span>, <span class="org-type">size_t</span> <span class="org-variable-name">new_length</span>);

<span class="org-type">void</span> <span class="org-function-name">resize</span>(<span class="org-type">HashMap</span> *<span class="org-variable-name">this</span>, <span class="org-type">size_t</span> <span class="org-variable-name">new_capacity</span>) {
    <span class="org-keyword">if</span> ((this-&gt;capacity) &gt;= new_capacity) <span class="org-keyword">return</span>;

    <span class="org-type">Entry</span> **<span class="org-variable-name">new_table</span> = alloc_array(<span class="org-keyword">sizeof</span>(<span class="org-keyword">struct</span> <span class="org-type">Entry</span>*), new_capacity);
    transfer(this-&gt;table, new_table, this-&gt;capacity, new_capacity);
    free(this-&gt;table);
    this-&gt;table = new_table;
    this-&gt;capacity = new_capacity;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-6028f8e2-fbd4-4c44-902a-ac4f1f638ca9" class="outline-4">
<h4 id="h-6028f8e2-fbd4-4c44-902a-ac4f1f638ca9"><span class="section-number-4">5.5.2.</span> Transferring Table Contents</h4>
<div class="outline-text-4" id="text-h-6028f8e2-fbd4-4c44-902a-ac4f1f638ca9">
<p>
Transferring the contents amounts to transferring rows in bucket <code>i</code>,
for <code>i=0</code> to the number of buckets.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>

<span class="org-keyword">static</span> <span class="org-type">void</span> <span class="org-function-name">transfer_rows</span>(<span class="org-type">Entry</span> *<span class="org-variable-name">row</span>, <span class="org-type">Entry</span> **<span class="org-variable-name">new_table</span>, <span class="org-type">size_t</span> <span class="org-variable-name">new_length</span>);

<span class="org-type">void</span> <span class="org-function-name">transfer</span>(<span class="org-type">Entry</span> **<span class="org-variable-name">old_table</span>, <span class="org-type">Entry</span> **<span class="org-variable-name">new_table</span>,
              <span class="org-type">size_t</span> <span class="org-variable-name">length</span>, <span class="org-type">size_t</span> <span class="org-variable-name">new_length</span>) {
    <span class="org-keyword">for</span>(<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = 0; i &lt; length; i++) {
        transfer_rows(old_table[i]; new_table, new_length);
    }
}

<span class="org-type">void</span> <span class="org-function-name">transfer_rows</span>(<span class="org-type">Entry</span> *<span class="org-variable-name">row</span>, <span class="org-type">Entry</span> **<span class="org-variable-name">new_table</span>, <span class="org-type">size_t</span> <span class="org-variable-name">new_length</span>) {
    <span class="org-type">Entry</span> *<span class="org-variable-name">e</span> = row;
    <span class="org-keyword">while</span> (<span class="org-constant">NULL</span> != e) {
        <span class="org-type">Entry</span> *<span class="org-variable-name">next</span> = e-&gt;next;
        <span class="org-type">size_t</span> <span class="org-variable-name">index</span> = indexFor(e-&gt;hash, new_length);
        <span class="org-comment-delimiter">// </span><span class="org-comment">entry_insert(&amp;new_table[index], e);</span>
        <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == new_table[index]) {
            e-&gt;next = <span class="org-constant">NULL</span>;
        } <span class="org-keyword">else</span> {
            e-&gt;next = new_table[index];
        }
        new_table[index] = e;
        e = next;
    }
}
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-h-607cbc47-b766-4a6a-b455-5616d02fc07b" class="outline-3">
<h3 id="h-607cbc47-b766-4a6a-b455-5616d02fc07b"><span class="section-number-3">5.6.</span> Removing a key from the Hash Map</h3>
<div class="outline-text-3" id="text-h-607cbc47-b766-4a6a-b455-5616d02fc07b">
<p>
If we want to disassociate a key from the hash map altogether (assuming
the hash map contains it), then we simply update the bucket containing
the associated hash.
</p>

<p>
Yes, I know about Linus Torvalds's commentary about using a double
pointer here, but I found it less clear after a second glance.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>

<span class="org-type">void</span> <span class="org-function-name">hashmap_remove</span>(<span class="org-type">HashMap</span> *<span class="org-variable-name">this</span>, <span class="org-type">Object</span> *<span class="org-variable-name">key</span>) {
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == this) <span class="org-keyword">return</span>;
    <span class="org-type">hash_t</span> <span class="org-variable-name">h</span> = hashCode(key);
    <span class="org-type">size_t</span> <span class="org-variable-name">index</span> = indexFor(h, this-&gt;capacity);
    <span class="org-type">Entry</span> *<span class="org-variable-name">entry</span> = this-&gt;table[index];
    <span class="org-type">Entry</span> *<span class="org-variable-name">prev</span> = <span class="org-constant">NULL</span>;

    <span class="org-keyword">while</span> (<span class="org-constant">NULL</span> != entry) {
        <span class="org-keyword">if</span> ((entry-&gt;hash == h) &amp;&amp; equals(entry-&gt;key, key)) {
            <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == prev) {
                this-&gt;table[index] = entry-&gt;next;
            } <span class="org-keyword">else</span> {
                prev-&gt;next = entry-&gt;next;
            }
            entry_free(&amp;entry);
            this-&gt;size--;
            <span class="org-keyword">return</span>;
        }
    }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-e5caef6b-d138-4449-bb4d-7c620b2dc2be" class="outline-3">
<h3 id="h-e5caef6b-d138-4449-bb4d-7c620b2dc2be"><span class="section-number-3">5.7.</span> Size of the Hash Map</h3>
<div class="outline-text-3" id="text-h-e5caef6b-d138-4449-bb4d-7c620b2dc2be">
<p>
The size of the hash map has been abstracted away to a helper function.
It just accesses the size field. For <code>*this</code> null pointers, it defaults
to zero.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>

<span class="org-type">size_t</span> <span class="org-function-name">hashmap_size</span>(<span class="org-type">HashMap</span> *<span class="org-variable-name">this</span>) {
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == this) <span class="org-keyword">return</span> 0;

    <span class="org-keyword">return</span> this-&gt;size;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-2cee9939-2abd-4aeb-9ae0-cb3c5c4cdc2e" class="outline-3">
<h3 id="h-2cee9939-2abd-4aeb-9ae0-cb3c5c4cdc2e"><span class="section-number-3">5.8.</span> Hash Code</h3>
<div class="outline-text-3" id="text-h-2cee9939-2abd-4aeb-9ae0-cb3c5c4cdc2e">
<p>
We can implement the hashcode computation as treating it as a list of
key-value entries.
</p>

<p>
(N.B. Java computes the hash code of a HashMap by iterating over the
entry set, and using their hash code computation for a generic list.
See, e.g., <a href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/classes/java/util/AbstractMap.java#L490-L496">AbstractMap::hashCode</a> in JDK8).
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>

<span class="org-keyword">static</span> <span class="org-type">hash_t</span> <span class="org-function-name">entry_hashCode</span>(<span class="org-type">Entry</span> *<span class="org-variable-name">entry</span>) {
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == entry) <span class="org-keyword">return</span> 0;
    <span class="org-keyword">else</span> <span class="org-keyword">return</span> hashCode(entry-&gt;key) ^ hashCode(entry-&gt;value);
}

<span class="org-type">hash_t</span> <span class="org-function-name">hashmap_hashCode</span>(<span class="org-type">HashMap</span> *<span class="org-variable-name">this</span>) {
    <span class="org-type">hash_t</span> <span class="org-variable-name">h</span> = 0;
    <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">row</span> = 0; row &lt; (this-&gt;capacity); row++) {
        <span class="org-keyword">for</span> (<span class="org-type">Entry</span> *<span class="org-variable-name">e</span> = (this-&gt;table[row]); <span class="org-constant">NULL</span> != e; e = e-&gt;next) {
            h += entry_hashCode(e);
        }
    }
    <span class="org-keyword">return</span> h;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-f5f33c7c-cab8-4091-ae36-a13a4fe0d0ac" class="outline-3">
<h3 id="h-f5f33c7c-cab8-4091-ae36-a13a4fe0d0ac"><span class="section-number-3">5.9.</span> Equality of Hash Maps</h3>
<div class="outline-text-3" id="text-h-f5f33c7c-cab8-4091-ae36-a13a4fe0d0ac">
<p>
This is trickier, but basically checks if every key in the <code>lhs</code> map
appears in the <code>rhs</code> map, and if that key is associated to the same
values. And if they have the same size, then the two hash maps are
equal, and the method returns true. All other scenarios return false.
</p>

<div class="org-src-container">
<pre class="src src-c"><span class="org-comment-delimiter">/* </span><span class="org-comment">types.c</span><span class="org-comment-delimiter"> */</span>

<span class="org-type">bool</span> <span class="org-function-name">hashmap_equals</span>(<span class="org-type">HashMap</span> *<span class="org-variable-name">lhs</span>, <span class="org-type">HashMap</span> *<span class="org-variable-name">rhs</span>) {
    <span class="org-keyword">if</span> (lhs == rhs) <span class="org-keyword">return</span> <span class="org-constant">true</span>;
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == lhs) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    <span class="org-keyword">if</span> (<span class="org-constant">NULL</span> == rhs) <span class="org-keyword">return</span> <span class="org-constant">false</span>;
    <span class="org-keyword">if</span> ((lhs-&gt;size) != (rhs-&gt;size)) <span class="org-keyword">return</span> <span class="org-constant">false</span>;

    <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">row</span> = 0; row &lt; (lhs-&gt;capacity); row++) {
        <span class="org-keyword">for</span> (<span class="org-type">Entry</span> *<span class="org-variable-name">e</span> = (lhs-&gt;table[row]); <span class="org-constant">NULL</span> != e; e = e-&gt;next) {
            <span class="org-keyword">if</span> (<span class="org-negation-char">!</span>equals(e-&gt;value, hashmap_get(rhs, e-&gt;key))) {
                <span class="org-keyword">return</span> <span class="org-constant">false</span>;
            }
        }
    }
    <span class="org-keyword">return</span> <span class="org-constant">true</span>;
}
</pre>
</div>
</div>
</div>

<div id="outline-container-h-1de2dc41-c561-4de7-8cad-5004ef30e23f" class="outline-3">
<h3 id="h-1de2dc41-c561-4de7-8cad-5004ef30e23f"><span class="section-number-3">5.10.</span> Hash Table References</h3>
<div class="outline-text-3" id="text-h-1de2dc41-c561-4de7-8cad-5004ef30e23f">
<ul class="org-ul">
<li><a href="http://coding-geek.com/how-does-a-hashmap-work-in-java/">How does a HashMap work in JAVA</a>
<ul class="org-ul">
<li>OpenJDK's implementation changed from a linked list (<a href="https://github.com/openjdk/jdk/blob/jdk8-b01/jdk/src/share/classes/java/util/HashMap.java">jdk8-b01</a>) to
use a binary tree for buckets with 8 or more elements (by <a href="https://github.com/openjdk/jdk/blob/jdk8-b120/jdk/src/share/classes/java/util/HashMap.java">jdk8-b120</a>)</li>
</ul></li>
<li>Intel's <a href="https://github.com/oneapi-src/oneTBB/blob/b15aabb39a12a4dcddb6ee886265f2bf2f972650/include/oneapi/tbb/concurrent_unordered_map.h"><code>concurrent_unordered_map</code></a></li>
<li>Attractive Chaos's <a href="https://github.com/attractivechaos/klib/blob/master/khash.h">khash</a>
<ul class="org-ul">
<li><a href="https://attractivechaos.wordpress.com/2008/09/02/implementing-generic-hash-library-in-c/">Implementation Notes</a></li>
<li><a href="https://attractivechaos.wordpress.com/2008/08/28/comparison-of-hash-table-libraries/">Comparison of Hash Table Libraries</a></li>
</ul></li>
<li><a href="https://rcoh.me/posts/hash-map-analysis/">An Analysis of Hash Map Implementations in Popular Languages</a></li>
<li>Common Lisp implementations all seem to use chaining
<ul class="org-ul">
<li><a href="https://github.com/sbcl/sbcl/blob/44125975b4d69d0ac3e289a4f8064f70a4164bfb/src/code/target-hash-table.lisp#L341-L533">SBCL</a></li>
<li><a href="https://github.com/Clozure/ccl/blob/c3b1e184539077d655b4b0cc1143ef6462f0d9b4/level-0/l0-hash.lisp#L426-L509">CCL</a></li>
<li><a href="https://github.com/armedbear/abcl/blob/321bac94a35f410af2a6b21847fed64b67c5e022/src/org/armedbear/lisp/HashTable.java#L39">ABCL</a></li>
</ul></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="postamble">Last Updated 2021-04-11 Sun 17:48.</p>
</div>
</body>
</html>