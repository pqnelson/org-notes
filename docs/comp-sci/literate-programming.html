<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Literate Programming</title>
<meta name="author" content="Alex Nelson" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=Spectral&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Merriweather" rel="stylesheet">
<div style="display: none"> \(
\DeclareMathOperator{\tr}{tr}
\newcommand\D{\mathrm{d}}
\newcommand\E{\mathrm{e}}
\newcommand\I{\mathrm{i}}
\newcommand\bigOh{\mathcal{O}}
\newcommand{\cat}[1]{\mathbf{#1}}
\newcommand\curl{\vec{\nabla}\times}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\ZZ}{\mathbb{Z}}
% For +---- metric
\newcommand{\BDpos}{}
\newcommand{\BDneg}{-}
\newcommand{\BDposs}{\phantom{-}}
\newcommand{\BDnegg}{-}
\newcommand{\BDplus}{+}
\newcommand{\BDminus}{-}
% For -+++ metric
\newcommand{\BDpos}{-}
\newcommand{\BDposs}{-}
\newcommand{\BDneg}{}
\newcommand{\BDnegg}{\phantom{-}}
\newcommand{\BDplus}{-}
\newcommand{\BDminus}{+}
\)</div>
<link rel="stylesheet" type="text/css" href="../css/stylesheet.css" />
<script>
  window.MathJax = {
    loader: {source: { '[tex]/amsCd': '[tex]/amscd',
                       '[tex]/AMScd': '[tex]/amscd'}},
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      inlineMath: {'[+]': [['$', '$']]},
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script  type="text/javascript"
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="./index.html"> UP </a>
 |
 <a accesskey="H" href="../index.html"> HOME </a>
</div><div id="content" class="content">
<h1 class="title">Literate Programming</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#h-8ab8f913-16f8-4655-9fef-2984e405acc7">1. Overview</a></li>
<li><a href="#h-517e67e5-c13f-472b-b4dc-7ceeb9c86a0c">2. Knuth's Web and CWeb</a>
<ul>
<li><a href="#h-1408ab8a-c9fd-4a50-b93d-0e4b0ac3c89b">2.1. Intention: Communicate with Human Beings</a>
<ul>
<li><a href="#h-710723e4-3bb5-497a-aaf6-68ba5b6a0eeb">2.1.1. Discussion of Variables</a></li>
<li><a href="#h-456c7846-6740-468d-90c9-84c11b770736">2.1.2. "Psychologically correct order"</a></li>
</ul>
</li>
<li><a href="#h-a6abaffd-932d-4741-a3d6-d732ba429779">2.2. Style</a>
<ul>
<li><a href="#h-4b97e024-6fc1-4fac-b928-82098bb2cab0">2.2.1. Naming Sections</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h-bac38627-9fb2-460c-9acc-bdc741cf76e0">3. Misinterpretations of Knuth</a></li>
<li><a href="#h-d4aa6d45-44e0-43db-bcc7-297a3b080e4d">4. My own experiences</a>
<ul>
<li><a href="#h-d1c72354-2668-4c9f-90ee-db891005b151">4.1. Thoughts on Making a Lisp</a></li>
<li><a href="#h-981d7f99-032c-4580-883a-9b4df7d0e8b5">4.2. Open Questions</a>
<ul>
<li><a href="#h-2c1bf083-d4c3-4a43-add0-2de462546fe3">4.2.1. What <i>is</i> the "Best" Order for Human Understanding?</a></li>
<li><a href="#h-64445936-a883-421c-a50a-d79e5307b025">4.2.2. "Explanation"?</a></li>
<li><a href="#h-a49ed96b-653c-43ac-86a9-2635b03b5a5b">4.2.3. Contracts</a></li>
<li><a href="#h-948bb08f-7ac3-4cb1-b0b0-73a4899d366c">4.2.4. Literate Proofs</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#h-54bc9d7c-f664-4f12-b9f9-635153bfd7be">5. Notes on Noweb</a></li>
<li><a href="#h-ddc775f3-b8ee-41c1-9e9a-5e72c11c81fd">6. Knuth's "Structured Programming with GOTO"</a>
<ul>
<li><a href="#h-da35167c-aed5-4551-82ec-fdf174bf17fa">6.1. "Structured" &#x2014; Data and Control</a></li>
<li><a href="#h-fb99dcb5-3e60-4150-b601-f23ea9e55b9d">6.2. Different Levels of Abstraction</a></li>
</ul>
</li>
<li><a href="#h-0d908a8a-fa3e-4ae8-86cb-f54cefb65dfb">7. References</a></li>
</ul>
</div>
</div>
<div id="outline-container-h-8ab8f913-16f8-4655-9fef-2984e405acc7" class="outline-2">
<h2 id="h-8ab8f913-16f8-4655-9fef-2984e405acc7"><span class="section-number-2">1.</span> Overview</h2>
<div class="outline-text-2" id="text-h-8ab8f913-16f8-4655-9fef-2984e405acc7">
<p>
Don Knuth coined the term "Literate Programming" to describing a
method of exposition coupled to writing computer software. It was
both literature and software. Unfortunately, since Javadoc,
everyone has co-opted the term to refer to inline documentation of
software, or something along those lines.
</p>

<p>
Knuth's idea works well for static projects, or for writing code
which non-programmer experts review. The latter case takes
advantage of the "Web style" the documentation affords, so a
non-programmer can read it as if it were pseudocode.
</p>

<p>
But it doesn't adequately work with agile methods. I'm not even
clear how to unit test code in this manner. If I had to iteratively
refine some code, I wouldn't know how to do that effectively. There
have been times when I wanted to create a stub, then revise it
later (so the chapter could form a self-contained
program). Literate programming doesn't handle the "then revise it
later" step. Presumably I could have used function pointers to
abstract away the methods used, or some other fancy trick.
</p>
</div>
</div>
<div id="outline-container-h-517e67e5-c13f-472b-b4dc-7ceeb9c86a0c" class="outline-2">
<h2 id="h-517e67e5-c13f-472b-b4dc-7ceeb9c86a0c"><span class="section-number-2">2.</span> Knuth's Web and CWeb</h2>
<div class="outline-text-2" id="text-h-517e67e5-c13f-472b-b4dc-7ceeb9c86a0c">
<p>
The original software Knuth used for literate programming which
allowed the author to extract Pascal code, which was then compiled
into a binary for execution. This is how Knuth wrote TeX, which was
then used to write Web (to make the documentation pretty).
</p>

<p>
A web program consists of "chunks". Each chunk was numbered, and
had some optional English text, followed by an optional source code
fragment, but must have at least one of either. (Empty chunks were
not allowed.) The code snippet could refer to other chunks as a
sort of pseudocode, writing something like <code>&lt;Sort applicants by
height&gt;</code> then later implement the code in a chunk named "Sort
applicants by height".
</p>

<p>
But Pascal didn't have the longevity of C.  Thus begat CWeb. It had
the same style of chunks, labels, etc., but used C code instead of
Pascal.
</p>
</div>
<div id="outline-container-h-1408ab8a-c9fd-4a50-b93d-0e4b0ac3c89b" class="outline-3">
<h3 id="h-1408ab8a-c9fd-4a50-b93d-0e4b0ac3c89b"><span class="section-number-3">2.1.</span> Intention: Communicate with Human Beings</h3>
<div class="outline-text-3" id="text-h-1408ab8a-c9fd-4a50-b93d-0e4b0ac3c89b">
<p>
Knuth explicitly pleas in his article "Literate Programming"
(1984):
</p>

<blockquote>
<p>
Let us change the traditional attitude to the construction of
programs. Instead of imagining that our main task is to instruct a
<i>computer</i> what to do, let us concentrate rather on explaining to
<i>human beings</i> what we want a computer to do.
</p>

<p>
The practitioner of literate programming can be regarded as an
essayist, whose main concern is with exposition and excellence of
style. Such an author, with thesaurus in hand, chooses the names of
variables carefully and explains what each variable means. He or
she strives for a program that is comprehensible because its
concepts have been introduced in an order that is best for human
understanding, using a mixture of formal and informal methods that
nicely reinforce each other.
</p>
</blockquote>

<p>
Sadly programmers do not view themselves as essayists while
programming. It's probably for this reason that literate
programming never caught on.
</p>
</div>
<div id="outline-container-h-710723e4-3bb5-497a-aaf6-68ba5b6a0eeb" class="outline-4">
<h4 id="h-710723e4-3bb5-497a-aaf6-68ba5b6a0eeb"><span class="section-number-4">2.1.1.</span> Discussion of Variables</h4>
<div class="outline-text-4" id="text-h-710723e4-3bb5-497a-aaf6-68ba5b6a0eeb">
<p>
Curiously, Knuth reflects about a few stylistic issues:
</p>

<blockquote>
<p>
The name of a section, enclosed in angle brackets, should be long
enough to encapsulate the essential characteristics of the code in that
section, but it should not be too verbose. I found very early that it would
be a mistake to include all of the assumptions about local and global
variables in the name of each section, even though such information
would strictly be necessary to isolate that section as an independent
module. The trick is to find a balance between formal and informal
exposition so that a reader can grasp what is happening without being
overwhelmed with detail. (See Naur [14].)
</p>
</blockquote>

<p>
I completely misread this the first time I read the article as
discouraging the discussion of variables <i>in the body</i> of a chunk.
</p>
</div>
</div>
<div id="outline-container-h-456c7846-6740-468d-90c9-84c11b770736" class="outline-4">
<h4 id="h-456c7846-6740-468d-90c9-84c11b770736"><span class="section-number-4">2.1.2.</span> "Psychologically correct order"</h4>
<div class="outline-text-4" id="text-h-456c7846-6740-468d-90c9-84c11b770736">
<p>
Knuth refers to the strength of literate programming as not being forced
to pick between "top-down" versus "bottom-up" design, stating in his
article "Literate Programming":
</p>

<blockquote>
<p>
And the fact that there's no need
to be hung up on the question of top-down versus bottom-up&#x2014;since a
programmer can now view a large program as a web, to be explored
in a psychologically correct order&#x2014;is perhaps the greatest lesson I have
learned from my recent experiences.
</p>
</blockquote>

<p>
I have been confused by this enigmatic phrase for a while. But when
reading his article on structured programming with the <code>goto</code> statement,
Knuth writes:
</p>

<blockquote>
<p>
Putting this another way, it is much better from a psychological
standpoint to write
</p>
<pre class="example" id="org3c90bdb">
loop until found ... ; found; ... repeat
</pre>
<p>
than to write
</p>
<pre class="example" id="org731655a">
search: while true do
begin ... ; leave search; ... end.
</pre>
<p>
The <code>leave</code> or <code>exit</code> statement is operationally the same, but intuitively
different, <b>since it talks more about the program than about the problem.</b>
</p>
</blockquote>

<p>
(Bold emphasis mine.)
</p>

<p>
It seems that one aspect of Knuth's use of the term "psychological" is
working at the level of abstraction suitable for stating the problem, in
a manner which is readily understandable and conceptually simple.
</p>
</div>
</div>
</div>
<div id="outline-container-h-a6abaffd-932d-4741-a3d6-d732ba429779" class="outline-3">
<h3 id="h-a6abaffd-932d-4741-a3d6-d732ba429779"><span class="section-number-3">2.2.</span> Style</h3>
<div class="outline-text-3" id="text-h-a6abaffd-932d-4741-a3d6-d732ba429779">
<p>
Chunk names seem to be frequently in the imperative mood ("See <code>foo</code>",
"Initialize <code>bar</code>", "Fetch <code>[data]</code>", etc.), at least in the TeXbook.
</p>

<p>
One observation is that Knuth usually writes in Pascal a function's
parameters and local variables, then uses "pseudocode chunk references"
like <code>&lt;Initialize bar&gt;</code> in the function's body.
</p>

<p>
Some numbers:
</p>
<ul class="org-ul">
<li>1379 chunks in <code>tex.web</code></li>
<li>6115 lines in <code>tex.p</code> (the tangled code), for an average of 4.434
lines of Pascal code per chunk</li>
<li>1216 <code>@d</code> definitions in <code>tex.web</code> in 214 chunks</li>
<li>13 <code>@f</code> format specifiers in <code>tex.web</code></li>
<li>125 chunks have no code segment</li>
<li>45 chunks have no code segment and no definition/formats</li>
<li>1254 chunks have code</li>
<li>504 chunks have no commentary (all of them have code, none have
definitions or formats)</li>
<li>Among all chunks,
<ul class="org-ul">
<li>average of 11.066 lines of code</li>
<li>median 9 lines of code</li>
<li>25th quartile: 4 lines of code</li>
<li>75h quartiles: 16</li>
<li>standard deviation: 9.14 lines of code</li>
<li>maximum of 115 lines of code in a single chunk</li>
<li>The quartiles among all chunks of code: 0 and 13 lines of code</li>
</ul></li>
<li>Among the chunks with code,
<ul class="org-ul">
<li>average of 12.16905 lines of code</li>
<li>standard deviation of 8.858455 lines of code</li>
<li>median of 10 lines of code</li>
<li>minimum of 2 lines of code</li>
<li>25h quartile: 6 lines of code</li>
<li>75th quartile: 16 lines of code</li>
</ul></li>
</ul>
</div>
<div id="outline-container-h-4b97e024-6fc1-4fac-b928-82098bb2cab0" class="outline-4">
<h4 id="h-4b97e024-6fc1-4fac-b928-82098bb2cab0"><span class="section-number-4">2.2.1.</span> Naming Sections</h4>
<div class="outline-text-4" id="text-h-4b97e024-6fc1-4fac-b928-82098bb2cab0">
<p>
Knuth has a number of "lessons learned" in the section "Stylistic
Issues" of his article on literate programming:
</p>

<blockquote>
<p>
The name of a section, enclosed in angle brackets, should be long
enough to encapsulate the essential characteristics of the code in that
section, but it should not be too verbose. I found very early that it would
be a mistake to include all of the assumptions about local and global
variables in the name of each section, even though such information
would strictly be necessary to isolate that section as an independent
module. The trick is to find a balance between formal and informal
exposition so that a reader can grasp what is happening without being
overwhelmed with detail. (See Naur [14].)
</p>

<p>
Another lesson I learned early in the game was that the name of a 
section should explicitly mention any nonstandard control structures, even
though its data structures can often be left implied. Furthermore, if the
control flow is properly explained, you can avoid the usual errors 
associated with <code>goto</code> statements; such statements can safely be introduced
in a restrained but natural manner.
</p>
</blockquote>
</div>
</div>
</div>
</div>
<div id="outline-container-h-bac38627-9fb2-460c-9acc-bdc741cf76e0" class="outline-2">
<h2 id="h-bac38627-9fb2-460c-9acc-bdc741cf76e0"><span class="section-number-2">3.</span> Misinterpretations of Knuth</h2>
<div class="outline-text-2" id="text-h-bac38627-9fb2-460c-9acc-bdc741cf76e0">
<p>
Following Knuth's enthusiastic examples, Javadoc added
documentation for Java code using comments. (Lisp had this earlier
in comment strings, but Javadoc extracted documentation from
specific comments.) Since then, the programming community had
misinterpreted "literate programming" as "programming with
API documentation embedded as comments".
</p>

<p>
Jupyter (formerly Python Notebooks) tried to introduce something
closer to Knuth's sense of literate programming, but it didn't
really adhere to Knuth's intentions. Org-babel seems to work along
similar lines as Jupyter.
</p>
</div>
</div>
<div id="outline-container-h-d4aa6d45-44e0-43db-bcc7-297a3b080e4d" class="outline-2">
<h2 id="h-d4aa6d45-44e0-43db-bcc7-297a3b080e4d"><span class="section-number-2">4.</span> My own experiences</h2>
<div class="outline-text-2" id="text-h-d4aa6d45-44e0-43db-bcc7-297a3b080e4d">
<p>
For the most part, it's fine. After having acquired a taste for
unit testing, it's a little unnatural at first (since C doesn't
have a unit testing framework). My exposition has been at the level
of documenting design decision, discussing alternatives, and so
on. I suspect this is not quite what Knuth had in mind.
</p>

<p>
The best example of a literate program, to my mind, is Bob
Nystrom's <a href="https://www.craftinginterpreters.com">Crafting Interpreters</a>. He wrote his own toolkit to splice
into his book (written in markdown) segments of code from a C
program (or Java program). This probably tells a lot about the
approach taken to writing a literate program, that the best one
wrote the code first (albeit with explanations in mind) and worked
a book around the code.
</p>

<p>
I dislike org-mode's literate programming features, since it
doesn't mesh well with org-mode. There's no way to create "chunks"
the same way I could in cweb. On the other hand, each chunk is
really six or seven stars, and I get to cluster them together in a
way that is natural for org-mode.
</p>
</div>
<div id="outline-container-h-d1c72354-2668-4c9f-90ee-db891005b151" class="outline-3">
<h3 id="h-d1c72354-2668-4c9f-90ee-db891005b151"><span class="section-number-3">4.1.</span> Thoughts on Making a Lisp</h3>
<div class="outline-text-3" id="text-h-d1c72354-2668-4c9f-90ee-db891005b151">
<p>
After some experiment with <a href="./mal-2.html">Making a Lisp</a>, I think one of the
disadvantages is: I want to get a small interpreter up and
running. But it's hard to organize the code such that I can revisit
a chunk and replace it. Consequently, it doesn't communicate to the
reader.
</p>

<p>
Knuth writes:
</p>

<blockquote>
<p>
But after gaining experience with WEB, I have come to realize that
there is no need to choose once and for all between top-down and
bottom-up, because a program is best tough of as a web instead of as
a tree. A hierarchical structure is present, but the most important
thing about a program is its structural relationships. A complex
piece of software consists of simple parts and simple relations
between those parts; the programmer's task is to state those parts
and those relationships, in whatever order is best for human
comprehension&#x2014;not in some rigidly determined order like top-down
or bottom-up.
</p>
</blockquote>

<p>
I don't think I adequately appreciate his examples. Perhaps I need
to sit down, and write code snippets on paper (as I write down
slips for my <i>Zettelk&auml;sten</i> with the chunk name in the top-right
corner, etc.), analogous to Knuth's chunks.
</p>
</div>
</div>
<div id="outline-container-h-981d7f99-032c-4580-883a-9b4df7d0e8b5" class="outline-3">
<h3 id="h-981d7f99-032c-4580-883a-9b4df7d0e8b5"><span class="section-number-3">4.2.</span> Open Questions</h3>
<div class="outline-text-3" id="text-h-981d7f99-032c-4580-883a-9b4df7d0e8b5">
<p>
There are a few things I'm uncertain about how to handle with
literate programming.
</p>
</div>
<div id="outline-container-h-2c1bf083-d4c3-4a43-add0-2de462546fe3" class="outline-4">
<h4 id="h-2c1bf083-d4c3-4a43-add0-2de462546fe3"><span class="section-number-4">4.2.1.</span> What <i>is</i> the "Best" Order for Human Understanding?</h4>
<div class="outline-text-4" id="text-h-2c1bf083-d4c3-4a43-add0-2de462546fe3">
<p>
This was never clear to me, and I know myself well enough to
know&#x2026;how I analyze things differs from how anyone else
would. Consequently, what's "best" for me differs from what's best
for anyone else. But I don't know how to begin, what order to
present material. Presumably this requires "big design up front",
which does not lend itself to rapid prototyping.
</p>

<p>
Explaining design choices, well, that doesn't seem to be taught
anywhere, ever. Consequently, instead of working through the design
in a manner suitable for human beings, it's easier to lapse back
into talking to the computer.
</p>
</div>
</div>
<div id="outline-container-h-64445936-a883-421c-a50a-d79e5307b025" class="outline-4">
<h4 id="h-64445936-a883-421c-a50a-d79e5307b025"><span class="section-number-4">4.2.2.</span> "Explanation"?</h4>
<div class="outline-text-4" id="text-h-64445936-a883-421c-a50a-d79e5307b025">
<p>
After thinking about it for a bit, I think one could describe
explanations in programming using the following terminology:
</p>

<ul class="org-ul">
<li>A <dfn>Problem</dfn> is what we're trying to solve or implement</li>
<li>A <dfn>Goal</dfn> translates our problem into some informal
specification</li>
<li>A <dfn>Plan</dfn> (or <i>pattern</i>) is a "canned solution" to a goal.</li>
</ul>

<p>
An explanation is the dialogue between goals and plans; for example, one
explanation could begin with articulating a goal, then presents a plan or
decomposes the goal into several sub-goals.
</p>

<p>
There are different levels of discussion. We could discuss:
</p>

<ul class="org-ul">
<li>The architecture of the program, as organized into modules or
components and their relation to each other</li>
<li>The design of a class, what it abstracts, the methods it contains</li>
<li>The design of a method or function</li>
</ul>

<p>
This is not complete, nor exhaustive. There are levels of discussion
between architecture and classes (e.g., design patterns could be used to
organize discussion of several classes).
</p>

<p>
<b>But this is not what happens in example literate programs!</b> For
example, in Knuth's <a href="http://www.literateprogramming.com/adventure.pdf"><code>adventure</code></a> literate program, there are no such
discussions.
</p>

<p>
One of the difficulties for <i>good writing</i> in literate programs is that
the design should be top-down (in the sense that the modules and
"important classes" are introduced, their interactions are defined,
etc.) but the programming should be bottom-up. An example of this style,
see Bob Nystrom's <a href="https://craftinginterpreters.com/">Crafting Interpreters</a>.
</p>

<p>
For more on the "goal-problem" perspective, see:
</p>

<ul class="org-ul">
<li>Elliot Soloway,<br>
"Learning to program = learning to construct mechanisms and explanations".<br>
<i>Communications of ACM</i> <b>29</b>, no.9 (1986) 850&#x2013;858
doi:<a href="https://doi.org/10.1145/6592.6594">10.1145/6592.6594</a>.</li>
</ul>
</div>
</div>
<div id="outline-container-h-a49ed96b-653c-43ac-86a9-2635b03b5a5b" class="outline-4">
<h4 id="h-a49ed96b-653c-43ac-86a9-2635b03b5a5b"><span class="section-number-4">4.2.3.</span> Contracts</h4>
<div class="outline-text-4" id="text-h-a49ed96b-653c-43ac-86a9-2635b03b5a5b">
<p>
When I program, I have gotten in the habit of using <code>assert</code>
preconditions and <code>assert</code> post-conditions. But literate
programming blurs the distinction between functions and
named-chunks. The former <i>can</i> have contracts, the latter should
not.
</p>

<p>
I suppose for a fragment of code in a chunk, this would become a
Hoare triple annotation.
</p>
</div>
</div>
<div id="outline-container-h-948bb08f-7ac3-4cb1-b0b0-73a4899d366c" class="outline-4">
<h4 id="h-948bb08f-7ac3-4cb1-b0b0-73a4899d366c"><span class="section-number-4">4.2.4.</span> Literate Proofs</h4>
<div class="outline-text-4" id="text-h-948bb08f-7ac3-4cb1-b0b0-73a4899d366c">
<p>
I'm writing a manuscript on implementing theorem provers. For this,
literate programming is a natural technique. It works fine. But
proving properties about the code I've written requires a different
style of writing, a different mode of presentation. Because I've
introduced a new metalanguage (the input language for the theorem
prover used to prove these properties). More generally, whenever
defining and implementing a language, I have the problems of
smoothly using all the tools at hand.
</p>

<p>
When I write the code in, say, C&#x2026;I need something like <a href="./acsl.html">ACSL</a> to
provide an annotated proof of Hoare triples. But <i>proving</i> the
Hoare triple annotations hold is done in the text, and is
<i>separate</i> from the essay explanation (at least, in my
mind). Consequently, I need some "literate proofs" of the Hoare
tripled. I suppose I could just shrug and hand it off to Frama-C to
check the annotations, but this doesn't seem friendly.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-h-54bc9d7c-f664-4f12-b9f9-635153bfd7be" class="outline-2">
<h2 id="h-54bc9d7c-f664-4f12-b9f9-635153bfd7be"><span class="section-number-2">5.</span> Notes on Noweb</h2>
<div class="outline-text-2" id="text-h-54bc9d7c-f664-4f12-b9f9-635153bfd7be">
<p>
I've been tinkering with Noweb to write a literate program in C, ACSL,
and Twelf. I think this may be a promising approach when working with
multiple languages.
</p>

<p>
Briefly commands:
</p>

<ul class="org-ul">
<li>Noweb files have a <code>.nw</code> suffix</li>
<li>Extract HTML: <code>noweave -filter l2h -index -html foo.nw &gt; foo.html</code></li>
<li>Extract TeX file: <code>noweave -x foo.nw &gt; foo.tex</code></li>
<li>Extract code: <code>notangle -L -Rfoo.c foo.nw &gt; foo.c</code></li>
</ul>

<p>
Formatting:
</p>

<ul class="org-ul">
<li><code>@</code> as the first character starts a documentation chunk</li>
<li>In LaTeX, <code>[[ ... ]]</code> for embedded code fragments</li>
<li>Use <code>noweave -delay</code> to avoid automatically wrapping a document class,
begin/end document environment</li>
<li>Start a code chunk with <code>&lt;&lt;name of chunk&gt;&gt;=</code></li>
<li>Insert a code chunk by reference with <code>&lt;&lt;...&gt;&gt;</code></li>
<li>Chunk naming conventions:
<ul class="org-ul">
<li>Name chunks inside functions with verbs, usually in imperative mood
("Do this", "Sort that", etc.)</li>
<li>Name chunks holding declaration prototypes with nouns (e.g.,
"private function prototypes", "definitions of exported functions", etc.)</li>
<li>Name top-level "root" chunks after the files they are to represent
(e.g., <code>&lt;&lt;foo.c&gt;&gt;=</code> or <code>&lt;&lt;foo.h&gt;&gt;=</code>)</li>
</ul></li>
</ul>
</div>
</div>
<div id="outline-container-h-ddc775f3-b8ee-41c1-9e9a-5e72c11c81fd" class="outline-2">
<h2 id="h-ddc775f3-b8ee-41c1-9e9a-5e72c11c81fd"><span class="section-number-2">6.</span> Knuth's "Structured Programming with GOTO"</h2>
<div class="outline-text-2" id="text-h-ddc775f3-b8ee-41c1-9e9a-5e72c11c81fd">
<p>
There are a few passages worth quoting from Knuth's article on
structured programming with the <code>goto</code> statement. In the discussion
after example 5a:
</p>

<blockquote>
<p>
If such automatic <code>goto</code> elimination procedures are applied to badly
structured programs, we can expect the resulting programs to be at
least as badly structured. Dijkstra pointed this out already in 1968 [21],
saying:
</p>

<pre class="example" id="orga2b325b">
    The exercise to translate an arbitrary flow diagram more or less 
    mechanically into a jumpless one, however, is not to be recommended.
    Then the resulting flow diagram cannot be expected to be more
    transparent than the original one.
</pre>

<p>
In other words, we shouldn't merely remove <code>goto</code> statements because
it's the fashionable thing to do; the presence or absence of goto 
statements is not really the issue. <b>The underlying structure of the program is</b>
<b>what counts, and we want only to avoid usages that somehow clutter up</b>
<b>the program.</b> Good structure can be expressed in FORTRAN or COBOL,
or even in assembly language, although less clearly and with much more
trouble. <b>The real goal is to formulate our programs in such a way that</b>
<b>they are easily understood.</b>
</p>

<p>
Program structure refers to the way in which a complex algorithm
is built up from successively simpler processes. In most situations this
structure can be described very nicely in terms of sequential 
compositions, conditionals, and simple iterations, together with <code>case</code> statements
for multiway branches. Undisciplined <code>goto</code> statements make program
structure harder to perceive, and they are often symptoms of a poor
conceptual formulation. But there has been far too much emphasis on
<code>goto</code> elimination instead of on the really important issues; people have
a natural tendency to set up an easily understood quantitative goal like
the abolition of jumps, instead of working directly for a qualitative goal
like good program structure. In a similar way, many people have set
up "zero population growth" as a goal to be achieved, when they really
desire living conditions that are much harder to quantify.
</p>

<p>
Probably the worst mistake any one can make with respect to the 
subject of <code>go to</code> statements is to assume that "structured programming" is
achieved by writing programs as we always have and then eliminating the
<code>goto</code>'s. Most <code>goto</code>'s shouldn't be there in the first place! What we 
really want is to conceive of our program in such a way that we rarely even
think about <code>goto</code> statements, because the real need for them hardly ever
arises. <b>The language in which we express our ideas has a strong influence</b>
<b>on our thought processes.</b> Therefore, Dijkstra [21] asks for more new
language features&#x2014;structures that encourage clear thinking&#x2014;in order
to avoid the <code>goto</code>'s temptations toward complications.
</p>
</blockquote>

<p>
Emphasis in bold is mine.
</p>
</div>
<div id="outline-container-h-da35167c-aed5-4551-82ec-fdf174bf17fa" class="outline-3">
<h3 id="h-da35167c-aed5-4551-82ec-fdf174bf17fa"><span class="section-number-3">6.1.</span> "Structured" &#x2014; Data and Control</h3>
<div class="outline-text-3" id="text-h-da35167c-aed5-4551-82ec-fdf174bf17fa">
<p>
Perhaps one of the ideas which has fallen into obscurity is the use of
the term "data structure" refers to something different than what we
think of it. There is concern about "well structured data", which sounds
odd to modern ears. Knuth explains:
</p>

<blockquote>
<p>
We also need well-structured data; i.e., as we write the program we
should have an abstract idea of what each variable means. This idea is
also usually describable as an invariant relation, e.g., "\(m\) is the number
of items in the table" or "\(x\) is the search argument" or "\(L[i]\) is the
number of the root node of node \(t\)'s left subtree, or 0 if this subtree is
empty" or "the contents of stack \(S\) are postponed obligations to do such
and such."
</p>
</blockquote>

<p>
I confess I have no adequate definition for an "invariant relation", I
suspect a good "first approximation" would be an assertion expected to hold.
</p>
</div>
</div>
<div id="outline-container-h-fb99dcb5-3e60-4150-b601-f23ea9e55b9d" class="outline-3">
<h3 id="h-fb99dcb5-3e60-4150-b601-f23ea9e55b9d"><span class="section-number-3">6.2.</span> Different Levels of Abstraction</h3>
<div class="outline-text-3" id="text-h-fb99dcb5-3e60-4150-b601-f23ea9e55b9d">
<p>
When pondering the definition of "structured programming", Knuth argues
it should not rely on <code>goto</code> statements at all. Instead, it should refer
to thinking at different "levels of abstraction" and the structure of
the program working at these different levels.
</p>

<blockquote>
<p>
Indeed, Dijkstra's original article [23], which gave structured 
programming its name, never mentioned <code>goto</code> statements at all! He directed
attention to the critical question, "For what program structures can
we give correctness proofs without undue labor, even if the programs
get large?" By correctness proofs he explained that he does not mean
formal derivations from axioms, he means any sort of proof (formal or
informal) that is "sufficiently convincing"; and <b>a proof really means an</b>
<b>understanding.</b> By program structure he means data structure as well
as control structure.
</p>

<p>
<b>We understand complex things by systematically breaking them into</b>
<b>successively simpler parts and understanding how these parts fit together</b>
<b>locally. Thus, we have different levels of understanding,</b> and each of those
levels corresponds to an <i>abstraction</i> of the detail at the level from which
it is composed. For example, at one level of abstraction, we deal with an
integer without considering whether it is represented in binary notation
or two's complement, etc., while at deeper levels this representation may
be important. At more abstract levels the precise value of the integer is
not important except as it relates to other data.
</p>
</blockquote>

<p>
(Bold emphasis mine, italics are Knuth's.)
</p>
</div>
</div>
</div>
<div id="outline-container-h-0d908a8a-fa3e-4ae8-86cb-f54cefb65dfb" class="outline-2">
<h2 id="h-0d908a8a-fa3e-4ae8-86cb-f54cefb65dfb"><span class="section-number-2">7.</span> References</h2>
<div class="outline-text-2" id="text-h-0d908a8a-fa3e-4ae8-86cb-f54cefb65dfb">
<ul class="org-ul">
<li>Donald Knuth,
<cite class="book-title">Literate Programming</cite>.
CSLI Lecture Notes no 27, 1992.</li>
<li>Donald Knuth,
<cite class="book-title">TeX: The Program</cite>.
Specifically the forward on "Reading a Web".</li>
<li>John Cook,
<a href="https://www.johndcook.com/blog/2016/07/06/literate-programming-presenting-code-in-human-order/">Literate programming: presenting code in human order</a>,
6 July 2016 blogpost.</li>
<li>Elliot Soloway,<br>
"Learning to program = learning to construct mechanisms and explanations".<br>
<i>Communications of ACM</i> <b>29</b>, no.9 (1986) 850&#x2013;858
doi:<a href="https://doi.org/10.1145/6592.6594">10.1145/6592.6594</a>.</li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="postamble">Last Updated: Sun, 26 Feb 2023 09:36:02 -0800
</div>
</body>
</html>
