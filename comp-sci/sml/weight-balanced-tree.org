#+TITLE: Weight-Balanced Tree - SML
#+AUTHOR: Alex Nelson
#+EMAIL: pqnelson@gmail.com
#+DATE: <2022-01-23T09:43:03-08:00>
#+LANGUAGE: en
#+OPTIONS: H:5
#+HTML_DOCTYPE: html5
#+INCLUDE: ../../org-macros.org
#+HTML_LINK_UP: ./index.html
#+HTML_LINK_HOME: ../../index.html
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="../../css/stylesheet.css" />
# Created Sunday January 23, 2022 at  9:43AM

* Introduction
:PROPERTIES:
:CUSTOM_ID: h-8246ebcc-2ee8-46a2-a4b0-ff9f094a23a6
:END:

Haskell uses [[https://en.wikipedia.org/wiki/Weight-balanced_tree][Weight-balanced trees]] in their implementations of sets and
maps. But their implementation is rather tricky. So I thought I would
write some notes about them.

#+begin_definition
A {{{dfn(Weight-balanced tree)}}} is either

1. the empty tree
2. a branch encoded as a tuple (weight, node value, left subtree, right subtree).
#+end_definition

Henceforth, we will take the size of the tree to be its weight. In
pidgin Standard ML:

#+begin_src sml
(* pidgin code *)
datatype 'a WBTree = E
       | T of int*'a*('a WBTree)*('a WBTree);
#+end_src

This doesn't quite work since we want to have a ~compare:'a*'a -> order~
function given. But SML's module system let's us guarantee this by
making ~WBTree~ a functor parametrized by an ~ORDERED~ module.

** Ordered Elements
:PROPERTIES:
:CUSTOM_ID: h-96e60562-fa51-44fd-b2c2-1808d0d7cc2b
:END:

Following Haskell's [[https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord][~Data.Ord~]] signature, we will provide a similar
~ORD~ signature. Usually it suffices to just define a ~compare~
function, then "fill in the gaps"; we thus define a ~COMPARABLE~
signature, and then an ~Ord~ functor to construct a module with the
~ORD~ signature.

#+begin_src sml
(* ord.sig *)

(* minimal signature which is fleshed out in a functor *)
signature COMPARABLE =
sig
    type t;
    val compare : t*t -> order;
end;

signature ORD =
sig
    type t;
    val compare : t*t -> order;
    val gt : t*t -> bool;
    val eq : t*t -> bool;
    val lt : t*t -> bool;
    val geq : t*t -> bool;
    val leq : t*t -> bool;
    val max : t*t -> t;
    val min : t*t -> t;
end;

functor Ord(Ordered : COMPARABLE) : ORD with type t = Ordered.t =
struct
    type t = Ordered.t;
    val compare = Ordered.compare;
    fun gt (x,y) = compare (x,y) = GREATER;
    fun eq (x,y) = compare (x,y) = EQUAL;
    fun lt (x,y) = compare (x,y) = LESS;
    fun geq (x,y) = not (lt (x,y));
    fun leq (x,y) = not (gt (x,y));
    fun max (x,y) = if lt(x,y) then y else x;
    fun min (x,y) = if lt(x,y) then x else y;
end;
#+end_src

** Initial Functor
:PROPERTIES:
:CUSTOM_ID: h-3aafa167-010e-4967-9a53-33ee50444f24
:END:

We also want a "smart constructor" which will automatically track the
size of the tree. This seems silly, but it saves a lot of concern later on.

#+begin_src sml
(* bin : Node.t -> t -> t -> t *)
fun bin x l r = T (1 + size l + size r, x, l, r);
#+end_src

Then a weight-balanced tree:

#+begin_src sml
(* wbtree.fun *)
functor WBTree(Node : ORD) =
struct
   datatype t = E | T of int*Node.t*t*t;

   val empty = E;
   fun singleton (v : Node.t) = T (1, v, E, E);

   fun size E = 0
     | size (T (n, _, _, _)) = n;

   fun bin x l r = T (1 + size l + size r, x, l, r);
   (* more to come *)
end;
#+end_src

** "Balanced" part of "Weight-Balanced Tree"
:PROPERTIES:
:CUSTOM_ID: h-2cd10aca-84b8-4cc0-b667-001e969d5738
:END:

#+begin_definition
We say a weight-balanced tree (n, x, L, R) is {{{dfn(Balanced)}}} if:
- When the subtrees L and R are both non-empty:
  ~Delta*(size(L)) > size(R)~ and ~Delta*size(R) > size(L)~;
- If either subtree is empty, the other is either a singleton or empty.
#+end_definition

The use of ~Delta~ allows some "wiggle room" in determining if a tree is
balanced. For example, when ~Delta~ is 2, and ~L~ = 5, then ~10 > R >= 3~
is the acceptable range of sizes for the right subtree.

When ~Delta~ is 3 and ~L~ = 5, then ~15 > R >= 2~ is an acceptable range
for the sizes for the right subtree.

#+begin_remark
There is some slight variation in the definition of a WBT being
balanced. For example, Hirai and Yamamoto define it as
~Delta*(size(R) + 1) >= size(L) + 1~ and
~Delta*(size(L) + 1) >= size(R) + 1~. This is a slightly more generous
condition; instead of ~Delta*size(L) > size(R) >= ceiling(size(L)/Delta)~,
we would allow ~Delta*size(L) + (Delta - 1) >= size(R) >= ceiling(size(L)/Delta) - 1~.
#+end_remark

We could implement this predicate in Standard ML as:

#+begin_src sml
(* wbtree.fun *)
functor WBTree(Node : ORD) =
struct
   datatype t = E | T of int*Node.t*t*t;

   val empty = E;
   fun singleton (v : Node.t) = T (1, v, E, E);

   fun size E = 0
     | size (T (n, _, _, _)) = n;

   val delta : int = 3;
   fun isBalanced E = true
     | isBalanced (T (_, _, l, r)) = delta*(1 + (size l)) >= 1 + size r andalso
                                     delta*(1 + (size r)) >= 1 + size l andalso
                                     isBalanced l andalso isBalanced r;
   (* more to come *)
end;
#+end_src

* Inserting a new value
:PROPERTIES:
:CUSTOM_ID: h-e6ca4f2a-c3b3-4a42-9eda-846b020acfdf
:END:

*Convention:* values found in the left subtree are /less than/ the value
of the root node, and values found in the right subtree are /greater than/
the value of the root node. (End of convention)

Suppose we had a tree of integers. Let us try maintaining our convention
with the implementation:

#+begin_src sml
(* first attempt *)
fun insert x E = singleton x
  | insert x (t as T (sz, v, l, r)) =
    case compare(x,v) of
       LESS => T (sz+1, v, insert x l, r)
     | EQUAL => t
     | GREATER T(sz + 1, v, l, insert x r);
#+end_src

This obeys our convention: every element of the right subtree is greater
than the root of the subtree, and every element of the left subtree is
less than the root of the subtree. But what happens with
~foldr (fn (x,tree) => insert x tree) E [1,2,3,4,5]~? Well, we get
~T(5,1,E, T(4,2,E, T(3,3,E, T(2,4,E, T(1, 5, E, E)))))~. Or, graphically:

#+CAPTION: Naive insertion of ~[1,2,3,4,5]~ into an empty tree.
[[../../img/tree-2.png]]

This is just a linked list with extra baggage! How can we fix this
situation?

Well, the astute reader will note our ~insert~ function does not check
if the subtrees are balanced. Why on Earth would anyone expect the
result to be a balanced tree?

We can remedy this by balancing the tree after inserting:

#+begin_src sml
(* insert : Node.t -> t -> t *)
fun insert x E = singleton x
  | insert x (tree as T (sz, v, l, r)) =
    case compare(x,v) of
       LESS => balanceL v (insert x l) r)
     | EQUAL => tree
     | GREATER => balanceR v l  (insert x r);
#+end_src

We call ~balanceL~ when inserting a new element into the left subtree
(or deleting something from the right subtree), which amounts to:

- check if the tree would be balanced
  - if so, then just construct the tree
  - otherwise rotate left "by some amount".

This is a classic trick with binary trees: rotations to rebalance them.
Tree rotation can graphically visualized as:

#+CAPTION: Single left and single right rotations of tree with $x < a < y < b < z$.
[[../../img/tree-1.png]]

The implementation of this, albeit unoptimized:

#+begin_src sml
(* balanceL : Node.t -> t -> t -> t *)
fun balanceL x l r = if isBalanced l r then T(1 + size l + size r, x, l, r)
                     else rotateL x l r;
#+end_src

Now it's just a matter to code up left rotations, right? Well, we also
have /double/ rotations. A {{{dfn(double left rotation)}}} moves a
"pivot" node "from the left" by two positions. Graphically:

#+CAPTION: Double left rotation of tree with $x < a < y < b < z$.
[[../../img/tree-3.png]]

This is done first by performing a "local right" rotation:

#+CAPTION: "Local right" rotation of tree with $x < a < y < b < z$.
[[../../img/tree-4.png]]

Then a "global left" rotation yields the result. We can similarly
construct a {{{dfn(double right rotation)}}} as moving a "pivot" node
"from the right" by two positions.

#+begin_src sml
(* rotateL : Node.t -> t -> t -> t *)
fun rotateL x l (r as (T (_,_,rl,rr))) =
    if isSingle rl rr then singleL x l r
    else doubleL x l r
  | rotateL _ _ _ = raise "rotateL";

fun singleL x l (T (_, v, rl, rr)) = bin y (bin x l rl) rr
  | singleL _ _ _ = raise "singleL";

fun doubleL x l (T (_, y, (T (_, z, rll, rlr)), rr))
    = bin z (bin x l rll) (bin y rlr rr)
  | doubleL _ _ _ = raise "doubleL";
#+end_src

But what is the condition for ~isSingle~? Basically, if the ratio of the
size of the left subtree to the size of the right subtree is less than
the ~Gamma~ parameter. For us, we name ~Gamma~ something more relevant,
~ratio~, and this condition becomes:

#+begin_src sml
(* isSingle : t -> t -> bool *)
fun isSingle l r = (size l + 1) < ratio*(size r + 1);
#+end_src

Thanks to the work of Hirai and Yamamoto, we know that ~delta = 3~ and
~ratio = 2~ are the only integer solutions, so we pick those values.
We combine these functions together, and our functor so far becomes:

#+begin_src sml
(* wbtree.fun *)
functor WBTree(Node : ORD) =
struct
   datatype t = E | T of int*Node.t*t*t;

   val empty = E;
   fun singleton (v : Node.t) = T (1, v, E, E);

   fun size E = 0
     | size (T (n, _, _, _)) = n;

   fun bin x l r = T(1 + size l + size r, x, l, r);

   (* laziness *)
   val compare = Node.compare;

   val ratio : int = 2;
   val delta : int = 3;

   (* isBalanced : t -> t -> bool *)
   fun isBalanced l r = delta*(size l + 1) >= (size r + 1);

   fun balanced E = true
     | balanced (T (_, _, l, r)) = isBalanced l r andalso
                                   isBalanced r l andalso
                                   balanced l andalso balanced r;

   (* Helper functions to ensure the tree isBalanced *)
   fun balanceL x l r = if isBalanced l r then bin x l r
                        else rotateL x l r;

   fun isSingle a b = (size a + 1) < gamma*(size b + 1);

   fun rotateL x l (r as (T (_,_,rl,rr))) =
       if isSingle rl rr then singleL x l r
       else doubleL x l r
     | rotateL _ _ _ = raise (Fail "rotateL");

   fun singleL x l (T (_, v, rl, rr)) = bin y (bin x l rl) rr
     | singleL _ _ _ = raise (Fail "singleL");

   fun doubleL x l (T (_, y, (T (_, z, rll, rlr)), rr))
       = bin z (bin x l rll) (bin y rlr rr)
     | doubleL _ _ _ = raise (Fail "doubleL");

   fun balanceR x l r = if isBalanced r l then bin x l r
                        else rotateR x l r;

   fun rotateR x (l as (T (_,_,ll,lr))) r =
       if isSingle ll lr then singleR x l r
       else doubleR x l r
     | rotateL _ _ _ = raise (Fail "rotateR");

   fun singleR x (T (_, v, ll, lr)) r = bin y ll (bin x lr r)
     | singleR _ _ _ = raise (Fail "singleR");

   fun doubleR z (T (_, x, ll, (T (_, y, lrl, lrr)))) r
       = bin y (bin x ll lrl) (bin z lrr r)
     | doubleR _ _ _ = raise (Fail "doubleR");

   (* insert : Node.t -> t -> t *)
   fun insert x E = singleton x
     | insert x (tree as T (sz, v, l, r)) =
       (case compare(x,v) of
           LESS => balanceL v (insert x l) r
         | EQUAL => tree
         | GREATER => balanceR v l  (insert x r));
   (* more to come *)
end;
#+end_src

#+begin_exercise
Assume ~l~ and ~r~ are balanced trees, and ~x~ is a value such that it
lies between the subtrees.

1. Prove ~balanceL x l r~ produces a balanced tree.
2. Prove ~balanceR x l r~ produces a balanced tree.
#+end_exercise

#+begin_exercise
Optimize our code. We proved it works (well, in an exercise), so prove
your optimizations "work" as well!
#+end_exercise

* Deleting an Element
:PROPERTIES:
:CUSTOM_ID: h-56f9e2fa-fedd-409c-9212-d511f7d42620
:END:

When deleting an element from a weight-balanced tree, we just need to do
the mirror image of an insertion (e.g., when deleting a value from the
left subtree, we need to invoke ~balanceR~). The only tricky bit is what
happens when we want to delete the value /at/ the root of the tree. Uh,
well, we'll just brush that problem into another function which will
~glue~ the subtrees into a new weight-balanced tree.

#+begin_src sml
(* delete : Node.t -> t -> t *)
fun delete _ E = E
  | delete x (tree as T (_, y, l, r)) =
    (case compare (x,y) of
         LESS => balanceR y (delete x l) r
       | EQUAL => glue l r
       | GREATER => balanceL y l (delete x r));
#+end_src

Now, how do we ~glue~ two weight-balanced trees together? There are some
simple cases: if ~l~ is empty, just return the right subtree; if ~r~ is
empty, return the left subtree.

When both ~l~ and ~r~ are non-empty, we have two cases:
1. ~size l > size r~, then we merge ~r~ into the right subtree of ~l~
   and invoke ~balanceR~ to produce a balanced tree;
2. otherwise, we merge ~l~ into the left subtree of ~r~ and invoke
   ~balanceL~ to produce a balanced tree.

#+begin_src sml
fun glue E r = r
  | glue l E = l
  | glue (l as T(sl,xl,ll,lr)) (r as T(sr,xr,lr,rr))
    = if sl > sr then (case maxView xl ll lr of
                           SOME (m, l') => balanceR m l' r
                         | _ => raise (Fail "glue sl > sr"))
      else (case minView xr lr rr of
                SOME (m, r') => balanceL m l r'
              | _ => raise (Fail "glue sl <= sr"));
#+end_src

We can get the maximum element of a tree, plus a version of the tree
with that element /removed/. How? Simply plumb the right subtree:

#+begin_src sml
fun maxViewSure x l E = (x, l)
  | maxView x l (T (_, xr, lr, rr)) =
    (case maxViewSure xr lr rr of
         (m, r') => (m, balanceL x l r'));

fun maxView E = NONE
  | maxView (T (_, x, l, r)) = SOME (maxViewSure x l r);
#+end_src

Similarly, the minimum element of the tree, and a version of the tree
with that element surgically removed:

#+begin_src sml
fun minViewSure x E r = (x, r)
  | minView x (T (_, xl, ll, lr)) r =
    (case minViewSure xl ll lr of
         (m, l') => (m, balanceR x l' r));

fun minView E = NONE
  | minView (T (_, x, l, r)) = SOME (minViewSure x l r);
#+end_src

Great, now we have the ability to insert and delete elements from our
weight-balanced tree.

#+begin_exercise
Prove, if ~tree~ is a /balanced/ weight-balanced tree containing the value ~x~,
then ~delete x tree~ produces a /balanced/ weight-balanced tree.
#+end_exercise

#+begin_exercise
Change our code for the case when ~x~ is not contained in ~tree~, then
we have ~delete x tree~ return the ~tree~ unmodified. [Hint: we cannot
use equality directly, but we know the size of the tree before and
after deletion will be the same if and only if they are the same.]
#+end_exercise

* References
:PROPERTIES:
:CUSTOM_ID: h-a3213d67-b211-41d1-baea-406a81802cfe
:END:

- Stephen Adams,\\
  "Functional Pearls: Efficient sets --- a balancing act".\\
  In /J. of Func. Progr./ *3* no.4 (1993) pp.553--561,
  [[https://www.cambridge.org/core/journals/journal-of-functional-programming/article/functional-pearls-efficient-setsa-balancing-act/0CAA1C189B4F7C15CE9B8C02D0D4B54E][Eprint]]
- Yoichi Hirai and Kazuhiko Yamamoto,\\
  "Balancing weight-balanced trees" (PDF).\\
  /Journal of Functional Programming/ *21* no.3 (2011): 287.
  [[https://yoichihirai.com/bst.pdf][PDF]]
- Lukas Barth and Dorothea Wagner,\\
  "Engineering Top-Down Weight-Balanced Trees".\\
  {{{arXiv(1910.07849)}}}, 14 pages.