#+TITLE: Weight-Balanced Tree - SML
#+AUTHOR: Alex Nelson
#+EMAIL: pqnelson@gmail.com
#+DATE: <2022-01-23T09:43:03-08:00>
#+LANGUAGE: en
#+OPTIONS: H:5
#+HTML_DOCTYPE: html5
#+INCLUDE: ../../org-macros.org
#+HTML_LINK_UP: ./index.html
#+HTML_LINK_HOME: ../../index.html
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="../../css/stylesheet.css" />
# Created Sunday January 23, 2022 at  9:43AM

* Introduction
:PROPERTIES:
:CUSTOM_ID: h-8246ebcc-2ee8-46a2-a4b0-ff9f094a23a6
:END:

Haskell uses [[https://en.wikipedia.org/wiki/Weight-balanced_tree][Weight-balanced trees]] in their implementations of sets and
maps. But their implementation is rather tricky. So I thought I would
write some notes about them.

#+begin_definition
A {{{dfn(Weight-balanced tree)}}} is either

1. the empty tree
2. a branch encoded as a tuple (weight, node value, left subtree, right subtree).
#+end_definition

Henceforth, we will take the size of the tree to be its weight. In
pidgin Standard ML:

#+begin_src sml
(* pidgin code *)
datatype 'a WBTree = E
       | T of int*'a*('a WBTree)*('a WBTree);
#+end_src

This doesn't quite work since we want to have a ~compare:'a*'a -> order~
function given. But SML's module system let's us guarantee this by
making ~WBTree~ a functor parametrized by an ~ORDERED~ module.

** Ordered Elements
:PROPERTIES:
:CUSTOM_ID: h-96e60562-fa51-44fd-b2c2-1808d0d7cc2b
:END:

Following Haskell's [[https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord][~Data.Ord~]] signature, we will provide a similar
~ORD~ signature. Usually it suffices to just define a ~compare~
function, then "fill in the gaps"; we thus define a ~COMPARABLE~
signature, and then an ~Ord~ functor to construct a module with the
~ORD~ signature.

#+begin_src sml
(* ord.sig *)

(* minimal signature which is fleshed out in a functor *)
signature COMPARABLE =
sig
    type t;
    val compare : t*t -> order;
end;

signature ORD =
sig
    type t;
    val compare : t*t -> order;
    val gt : t*t -> bool;
    val eq : t*t -> bool;
    val lt : t*t -> bool;
    val geq : t*t -> bool;
    val leq : t*t -> bool;
    val max : t*t -> t;
    val min : t*t -> t;
end;

functor Ord(Ordered : COMPARABLE) : ORD with type t = Ordered.t =
struct
    type t = Ordered.t;
    val compare = Ordered.compare;
    fun gt (x,y) = compare (x,y) = GREATER;
    fun eq (x,y) = compare (x,y) = EQUAL;
    fun lt (x,y) = compare (x,y) = LESS;
    fun geq (x,y) = not (lt (x,y));
    fun leq (x,y) = not (gt (x,y));
    fun max (x,y) = if lt(x,y) then y else x;
    fun min (x,y) = if lt(x,y) then x else y;
end;
#+end_src

** Initial Functor
:PROPERTIES:
:CUSTOM_ID: h-3aafa167-010e-4967-9a53-33ee50444f24
:END:

Then a weight-balanced tree:

#+begin_src sml
(* wbtree.fun *)
functor WBTree(Node : ORD) =
struct
   datatype t = E | T of int*Node.t*t*t;

   val empty = E;
   fun singleton (v : Node.t) = T (1, v, E, E);

   fun size E = 0
     | size (T (n, _, _, _)) = n;
   (* more to come *)
end;
#+end_src

** "Balanced" part of "Weight-Balanced Tree"
:PROPERTIES:
:CUSTOM_ID: h-2cd10aca-84b8-4cc0-b667-001e969d5738
:END:

#+begin_definition
We say a weight-balanced tree (n, x, L, R) is {{{dfn(Balanced)}}} if:
- When the subtrees L and R are both non-empty:
  ~Delta*(size(L)) > size(R)~ and ~Delta*size(R) > size(L)~;
- If either subtree is empty, the other is either a singleton or empty.
#+end_definition

The use of ~Delta~ allows some "wiggle room" in determining if a tree is
balanced. For example, when ~Delta~ is 2, and ~L~ = 5, then ~10 > R >= 3~
is the acceptable range of sizes for the right subtree.

When ~Delta~ is 3 and ~L~ = 5, then ~15 > R >= 2~ is an acceptable range
for the sizes for the right subtree.

#+begin_remark
There is some slight variation in the definition of a WBT being
balanced. For example, Hirai and Yamamoto define it as
~Delta*(size(R) + 1) >= size(L) + 1~ and
~Delta*(size(L) + 1) >= size(R) + 1~. This is a slightly more generous
condition; instead of ~Delta*size(L) > size(R) >= ceiling(size(L)/Delta)~,
we would allow ~Delta*size(L) + (Delta - 1) >= size(R) >= ceiling(size(L)/Delta) - 1~.
#+end_remark

We could implement this predicate in Standard ML as:

#+begin_src sml
(* wbtree.fun *)
functor WBTree(Node : ORD) =
struct
   datatype t = E | T of int*Node.t*t*t;

   val empty = E;
   fun singleton (v : Node.t) = T (1, v, E, E);

   fun size E = 0
     | size (T (n, _, _, _)) = n;

   val delta : int = 3;
   fun isBalanced E = true
     | isBalanced (T (_, _, l, r)) = delta*(1 + (size l)) >= 1 + size r andalso
                                     delta*(1 + (size r)) >= 1 + size l andalso
                                     isBalanced l andalso isBalanced r;
   (* more to come *)
end;
#+end_src

* Inserting a new value
:PROPERTIES:
:CUSTOM_ID: h-e6ca4f2a-c3b3-4a42-9eda-846b020acfdf
:END:

*Convention:* values found in the left subtree are /less than/ the value
of the root node, and values found in the right subtree are /greater than/
the value of the root node. (End of convention)

Suppose we had a tree of integers. Let us try maintaining our convention
with the implementation:

#+begin_src sml
fun insert x E = singleton x
  | insert x (t as T (sz, v, l, r)) =
    case compare(x,v) of
       LESS => T (sz+1, v, insert x l, r)
     | EQUAL => t
     | GREATER T(sz + 1, v, l, insert x r);
#+end_src

This obeys our convention: every element of the right subtree is greater
than the root of the subtree, and every element of the left subtree is
less than the root of the subtree. But what happens with
~foldr (fn (x,tree) => insert x tree) E [1,2,3,4,5]~? Well, we get
~T(5,1,E, T(4,2,E, T(3,3,E, T(2,4,E, T(1, 5, E, E)))))~. Or, graphically:

#+CAPTION: Naive insertion of ~[1,2,3,4,5]~ into an empty tree.
[[../../img/tree-2.png]]

This is just a linked list with extra baggage! How can we fix this
situation?

Well, the astute reader will note our ~insert~ function does not check
if the subtrees are balanced. Why on Earth would anyone expect the
result to be a balanced tree?

#+CAPTION: Left and right rotations of tree.
[[../../img/tree-1.png]]




* References
:PROPERTIES:
:CUSTOM_ID: h-a3213d67-b211-41d1-baea-406a81802cfe
:END:

- Stephen Adams,\\
  "Functional Pearls: Efficient sets --- a balancing act".\\
  In /J. of Func. Progr./ *3* no.4 (1993) pp.553--561,
  [[https://www.cambridge.org/core/journals/journal-of-functional-programming/article/functional-pearls-efficient-setsa-balancing-act/0CAA1C189B4F7C15CE9B8C02D0D4B54E][Eprint]]
- Yoichi Hirai and Kazuhiko Yamamoto,\\
  "Balancing weight-balanced trees" (PDF).\\
  /Journal of Functional Programming/ *21* no.3 (2011): 287.
  [[https://yoichihirai.com/bst.pdf][PDF]]
- Lukas Barth and Dorothea Wagner,\\
  "Engineering Top-Down Weight-Balanced Trees".\\
  {{{arXiv(1910.07849)}}}, 14 pages.