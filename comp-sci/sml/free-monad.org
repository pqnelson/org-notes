#+TITLE: Free Monads - SML
#+AUTHOR: Alex Nelson
#+EMAIL: pqnelson@gmail.com
#+DATE: <2025-02-22T15:26:57-08:00>
#+LANGUAGE: en
#+OPTIONS: H:5
#+HTML_DOCTYPE: html5
#+INCLUDE: ../../org-macros.org
#+HTML_LINK_UP: ./index.html
#+HTML_LINK_HOME: ../../index.html
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="../../css/stylesheet.css" />
# Created Saturday February 22, 2025 at  3:26PM

* Overview
:PROPERTIES:
:CUSTOM_ID: h-d40ee261-e0d6-4991-9643-dd465129632e
:END:

The basic idea underlying free monads is to start with an endofunctor
$f$ and then turn it into a monad, just as the free group starts with
a set then turns it into a group.

Free monads are useful when it comes into describing side-effects
monadically. 

Haskell takes this idea and runs with it.

We will see how this works in Standard ML.

* Functors in SML
:PROPERTIES:
:CUSTOM_ID: h-77ec8efc-07fa-4faa-b0d3-52077da95d9a
:END:

A ~Functor~ (not to be confused with the builtin ~functor~ keyword in
the module language) is a structure adhering to the following
signature:

#+begin_src sml
signature FUNCTOR = sig
  type 'a t;
  val map : ('a -> 'b) -> 'a t -> 'b t;
end;
#+end_src

That's all we need. There are two functor laws, which are inspired by
category theory. If ~F~ is a functor, then...

- unit law: ~F.map id == id~
- preserves composition: ~F.map (g o f) = (F.map g) o (F.map f)~

Ta-duh!

(See also the [[file:functor.org][dedicated discussion]] about functors on its own page.)

* Free Monads
:PROPERTIES:
:CUSTOM_ID: h-39916d46-ea6d-4955-bda1-2e7a30a9742c
:END:

** Monad signature
:PROPERTIES:
:CUSTOM_ID: h-0744c31b-75ad-4322-a576-13930453262f
:END:

Just to review, we have the following signature for monads in Standard ML:

#+begin_src sml
signature MONAD = sig
  include FUNCTOR;
  val return : 'a -> 'a t;
  val bind : 'a t -> ('a -> 'b t) -> 'b t;
  val join : 'a t t -> 'a t;
end;
#+end_src

We may or may not need the ~exec~ function to /perform/ the computation abstracted
away by the monad.

** Free Monad Signature
:PROPERTIES:
:CUSTOM_ID: h-21c5ddfd-166b-4d71-a374-b0957f4c2c33
:END:

A free monad will take a ~Functor~, and turn it into a monad. The
~Functor~ is kept as a field of the structure.

Intuitively, a free monad is generated by a "join" operation (or
"multiplication") operation. It suffices to describe this using a
datatype with ~Return of 'a~ and =Join of 'a t F.t=, so the operations
"stack" as we'd expect from a free gadget.

We then have the following signature:

#+begin_src sml
signature FREE_MONAD = sig
  structure F : FUNCTOR;
  (* probably should rename the constructors to the more
  intuitive RETURN of 'a | JOIN of ('a t) F.t
  since $\mu$ corresponds to the `join` function for a monad.
  This `JOIN` constructor wraps the "outer" functor as a
  placeholder. *)
  datatype 'a t = Return of 'a
                | Join of ('a t) F.t;
  val return : 'a -> 'a t;
  val bind : 'a t -> ('a -> 'b t) -> 'b t;
  val join : 'a t t -> 'a t;
  val map : ('a -> 'b) -> 'a t -> 'b t;
  val lift : 'a F.t -> 'a t;
  (* lift is analogous to (fn x => [x]) *)
  (* fun lift x = Join (F.fmap Return x); *)

  (* val fold : ('a F.t -> 'a) -> 'a m -> 'a; *)
(* fun fold _ (Return a) = a
     | fold f (Join x) = f (F.fmap (fold f) x);
*)
end;
#+end_src

Note that we need to "hack" the SML module system to make this a
functor. The type alias ~type 'a t = 'a m~ accomplishes this. See Bob
Harper's [[https://www.cs.cmu.edu/~rwh/isml/book.pdf][Programming in SML]], Section 18.1, for details. (We could have
written something like ~include MONAD; include FUNCTOR where type 'a
t = 'a m~ in the signature, but it would not change the implementation
as a structure or functor).

Here ~Return~ and ~Join~ are [data] constructors for the free monad
generated by the Functor ~F~.

The bind function (which tells us everything we'd want to know about
a monad) is the "default implementation" in terms of ~Join~ and ~F.map~
with some subtlety. Normally we would have ~x >>= f = join (F.map f x)~
but we need to "propagate" the ~(>>= f)~ down; i.e., we would have
~join (F.map (fn m => bind m f) x)~ be the bind function.

The ~bind~ implementation amounts to more of a ~map~ than anything else.
(In fact, we need to patch this up later on if we want to use
~Free(F)~ as a monad; we can redefine ~fun bind m f = join (map f m)~
at the end of the functor structure's body to avoid this.)

Also observe we include the ~where type...~ clause to make
public the underlying functor's type:

#+begin_src sml
functor Free(F : FUNCTOR) :> FREE_MONAD
                               where type 'a F.t = 'a F.t
                                 = struct
  structure F = F;
  datatype 'a t = Return of 'a
                | Join of ('a t) F.t;

  (* return : 'a -> 'a t *)
  fun return x = Return x;

  (* bind : 'a t -> ('a -> 'b t) -> 'b t
   KLUDGE: requires cleaning up with the Monadify functor *)
  fun bind (Return x) f = f x
    | bind (Join x) f = Join (F.map (fn m => bind m f) x);

  (* map : ('a -> 'b) -> 'a t -> 'b t *)
  fun map f m = bind m (fn x => return (f x));
  
  (* lift : 'a F.t -> 'a t *)
  fun lift f = Join (F.map return f);

  (* join : 'a t t -> 'a t *)
  fun join m = bind m (fn x => x);
end;
#+end_src

Another way to approach this is to first implement the ~map~ function,
then the ~join~ function, and then the ~bind~ function follows as the
default implementation as:

#+begin_src sml
functor Free(F : FUNCTOR) :> FREE_MONAD
                               where type 'a F.t = 'a F.t
                                 = struct
  structure F = F;
  datatype 'a t = Return of 'a
                | Join of ('a t) F.t;
  (* return : 'a -> 'a t *)
  fun return x = Return x;

  fun map f (Return a) = Return (f a)
    | map f (Join x) = Join (F.map (map f) x);

  fun join (Return x) = x
    | join (Join x) = Join (F.map join x);

  fun bind m f = join (map f m);
  
  (* lift : 'a F.t -> 'a t *)
  fun lift f = Join (F.map return f);
end;
#+end_src

This is actually a bit more explicit than the Haskell type signatures,
since Haskell does not distinguish which instance each ~fmap~ comes from.

Furthermore, this uses the /correct/ implementation of ~bind~ which
avoids requiring the ~Monadify~ functor below.

** Compared to Free Monoid
:PROPERTIES:
:CUSTOM_ID: h-f82f46d4-0bb4-4502-bc6e-f429a310b41a
:END:

The free monoid is precisely the list. The analogy with free monads
should be:

#+begin_example
datatype 'a list =          nil | cons of 'a * 'a list;
(* structure F : FUNCTOR *)
datatype 'a Free = Return of 'a | Join of ('a Free) F.t;
#+end_example

** Example: IO
:PROPERTIES:
:CUSTOM_ID: h-2cf63700-06e7-4bb3-90d4-ad0e0c659760
:END:

We can use the free monad to describe a simple IO monad. Where to
start?

First we need to construct a functor with the various operations we'd
like to perform. For now, simply printing a string to the screen and
reading a string from ~stdIn~ suffices:

#+begin_src sml
(* A functor describing the operations with side-effects in IO

In general, an operation `Foo : A -> B -> C -> Z IO.t` would
be encoded by a data constructor `FooOp of A * B * C * (Z -> 'a)`.

We also treat `unit -> 'a` as interchangeable with `'a`.
 *)
structure IO_Op = struct
  datatype 'a t = Print of (string * 'a)
                | Read of (string -> 'a);
  fun map f (Print (s,k)) = Print (s, f k)
    | map f (Read k) = Read (fn s => f (k s));
end;
#+end_src

We will also have a ~read_line~ function which we need to implement
(it's straightforward):

#+begin_src sml
fun read_line () =
  case TextIO.inputLine TextIO.stdIn of
      SOME s => s
    | NONE => "";
#+end_src

Now we can recall the ~bind~ function may be defined in terms of the
monadic ~join~ operation and the functor's ~map~ operation. To recover
this for the free monad (which any programmer /using/ this library
would expect as the intended behaviour --- see, e.g., Bartosz
Milewski's [[https://github.com/hmemcpy/milewski-ctfp-pdf/releases/download/v1.3.0/category-theory-for-programmers.pdf][Category Theory for Programmers]], section 20.2), we need
something like the following:

#+begin_src sml
(* post hoc patch to initial attempt at Free(...) functor *)
functor Monadify(M : MONAD) = struct
  type 'a t = 'a M.t;
  val map = M.map;
  val return = M.return;
  val join = M.join;
  (* The `bind` operation is induced by the monadic `join` and
  the functorial `map`, as category theory dictates. *)
  fun bind m f = join (map f m);
  fun then m n = bind m (fn _ => n);
end;
#+end_src

(If you do not want this, you can modify the implementation of the
~Free~ functor to add ~fun bind m f = join (map f m);~ as the last
declaration of the structure. This will make the public-facing ~bind~
function what the user would expect/hope.)

Now we can put all these pieces together to form the free monad
describing IO side effects we prescribed:

#+begin_src sml
local
  structure FreeIO = Free(IO_Op);
  structure Io_ = Monadify(FreeIO);
in
  structure Job : sig
      datatype t = datatype FreeIO.t
      val bind: 'a t -> ('a -> 'b t) -> 'b t
      val join: 'a t t -> 'a t
      val map: ('a -> 'b) -> 'a t -> 'b t
      val return: 'a -> 'a t
      val unsafePerform: 'a t -> 'a
  end = struct
    open Io_;
    (* datatype replication to make the constructors public *)
    datatype t = datatype FreeIO.t;
    (* execute the monad *)
    fun unsafePerform (Return x) = x
      | unsafePerform (Join f) =
        case f of
            (IO_Op.Print (s, k)) => (print s;
                                     unsafePerform k)
          | (IO_Op.Read k) => unsafePerform (k (read_line()));
  end
end;
#+end_src

** Example usage of IO Free Monad
:PROPERTIES:
:CUSTOM_ID: h-30769603-579e-490f-9b5f-415be5f52488
:END:

We can now use the previous machinations in a toy example:

#+begin_src sml
infix >> >>=
fun ((m : 'a Job.t) >>= (n : 'a -> 'b Job.t)) = Job.bind m n;
fun (m >> n) = Job.bind m (fn _ => n);

fun print_string msg =
  Job.Join (IO_Op.Print (msg, Job.Return ()));
val read_string =
  Job.Join (IO_Op.Read (fn msg => Job.Return msg));
fun main () =
  (print_string "What's your name? ") >>
    (read_string >>= (fn name => 
                       (print_string "Hello, ") >>
                         (print_string name)));

Job.unsafePerform (main ());
#+end_src

This isn't terribly different than the IO Monad implemented in
Standard ML as found in Andrew Gordon's PhD dissertation.


* Concluding Remarks
:PROPERTIES:
:CUSTOM_ID: h-08b0c8ac-8f74-470e-af25-5de34356a429
:END:

The Free monad is used to decompose an embedded DSL, but in Haskell it
comes at the cost of losing a lot of compiler optimizations. So
instead it's preferable to use the MTL monad transformer library.

The other use for Free monads is to containerize side-effects (or
other effects). 

* References
:PROPERTIES:
:CUSTOM_ID: h-0a2734cf-f3b6-433b-9422-343aac57d70f
:END:

- [[https://okmij.org/ftp/Computation/free-monad.html][Free and Freer Monads: Putting Monads Back into Closet]]
- [[https://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html][Why Free Monads Matter]]
- [[https://underscore.io/blog/posts/2015/04/23/deriving-the-free-monad.html][Deriving the Free Monad]]
- [[http://rgrinberg.com/posts/free-monads-in-the-wild-ocaml/][Free Monads in the Wild - OCaml Edition]]
- [[https://www.parsonsmatt.org/2017/09/22/what_does_free_buy_us.html][What does Free buy us?]]
- Jeremy Mikkola's [[https://jeremymikkola.com/posts/2017_07_11_free_monad_cheatsheet.html][Cheatsheet: Free Monad]]
- [[https://joa.sh/posts/2016-07-29-free-monad-steps.html][Free monad in 7 steps]]
  
Some subtleties around the sensationalist hype about Free Monads:
- [[https://markkarpov.com/post/free-monad-considered-harmful][Free monad considered harmful]]
- [[https://www.atamo.com/articles/free-monads-wont-detox-your-colon/][Free monads won't detox your colon]]

** Examples in OCaml
:PROPERTIES:
:CUSTOM_ID: h-c1498249-8e2b-4bf5-9909-c1df4c7a08d5
:END:

- Nick Vanderweit's [[https://gist.github.com/nvanderw/8995984][Free monads in OCaml]] 