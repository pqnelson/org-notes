#+TITLE: Make a Lisp
#+AUTHOR: Alex Nelson
#+EMAIL: pqnelson@gmail.com
#+LANGUAGE: en
#+INCLUDE: "../../org-macros.org"
#+OPTIONS: H:5
#+HTML_DOCTYPE: html5
# Created Saturday December 12, 2020 at 10:48AM
#+HTML_LINK_UP: ../lisp.html
#+HTML_LINK_HOME: ../../index.html
#+HTML_HEAD_EXTRA: <link rel="stylesheet" type="text/css" href="../../css/stylesheet.css" />

*Warning:* This is a work in progress, trying to work on some literate
program to experiment with such a writing style.

* Roadmap

After Clojure sparked renewed interest in [[./lisp.org][Lisp]], someone started a
[[https://github.com/kanaka/mal]["Make a Lisp"]] project on Github. It was a guided tutorial on how to
implement a Clojure-like language from scratch. The scope was
smaller than Henderson's /Functional Programming/ (1980) which
compiled a Lisp to [[./abstract-machines/secd.org][SECD]] machine instructions.

We will be making a Lisp. Although our Lisp will be modeled after
some blend of Common Lisp and Scheme (favoring the Common Lisp
syntax but the Lisp-1 flavor of Scheme), in the sense of both
concrete syntax and reader macros.

I'm also curious about correctness concerns. So I'll be thinking in
terms of proving each function does what I intend. Towards this
end, we will be using the [[file:../acsl.org][ANSI-C Specification Language]] to annotate
our C code.

** Conventions

Following [[https://www.gnu.org/software/guile/manual/html_node/API-Overview.html#API-Overview][Guile's C conventions]] (see also Clojure's [[https://github.com/clojure/clojure/blob/clojure-1.10.1/src/jvm/clojure/lang/Compiler.java#L2851-L2876][munge]] translation
table for characters) I'm going to try to "mangle" Lisp
identifiers into C code as follows:

- Replace =-= (hypen) with ~_~ (underscore)
- Replace =?= (question mark) with ~_p~
- Replace =!= (exclamation point) with ~_x~
- Replace =->= with ~_to_~
- Replace ~<=~ with =_leq=
- Replace ~>=~ with =_geq=
- Replace ~<~ with =_less=
- Replace ~>~ with =_gr=

* Lisp Reader

We need to get started reading and printing. Although the readline
library is suited for this job, it causes quite great difficulties
for valgrind (making debugging impossible, or harder than I can
tolerate).

Once we get input from the REPL, we need to tokenize the string,
which is then fed to the reader. The tokenizer discerns each
character fed to it, and accumulates them into tokens /or/ invokes
reader macros.

In pseudocode, the =read_form()= looks like:

#+begin_example
LispValue* read_form(char *input) {
    Tokenizer *tokenizer = tokenizer_new(input);
    LispValue *value = read_from_tokenizer(tokenizer);
    tokenizer_free(tokenizer);
    return value;
}

LispValue* read_from_tokenizer(Tokenizer *tokenizer) {
    Token *current = peek(tokenizer);
    if (L_PAREN == current->type) {
        return read_list(tokenizer);
    } else {
        return read_atom(tokenizer);
    }
}
#+end_example

The tokenizer owns the input string, and is responsible for freeing
it. When creating a symbol or string, we must create new strings
and then the corresponding Lisp object owns them.

** Tokenizer

The tokenizer needs to track which character is being tokenized,
the start of the input string (for later use when freeing it), and
presumably some other stuff.

*** Header Definitions

#+begin_src C :noweb no-export :tangle ../src/mal/tokenizer.h
#ifndef LISP_TOKENIZER_H
#define LISP_TOKENIZER_H

<<Token header data structures>>

<<Token function prototypes>>
#endif /* LISP_TOKENIZER_H */
#+end_src

**** Tokenizer Data Structure

The tokenizer itself needs to track the start of the input string,
the current position, and presumably a few other metadata
fields. For now we have two pointers for it.

#+begin_src C :noweb-ref Token header data structures
typedef struct Tokenizer {
    char *start, *current;
    struct Token *token;
} Tokenizer;
#+end_src

**** Token Data Structure

The =Token= data structure has the string segment as an array of
bytes. We want to avoid allocating memory needlessly, so instead it
has a pointer to the string buffer owned by the =Tokenizer= /and/ a
length field. We'll also track what type of token we're working
with. For convenience, we will also have an enumeration of token
types. In practice, for a later second-pass, we wouldn't want it;
we would want to hew closer to the algorithm outlined in
{{{book-title(Common Lisp the Language)}}} (ch. 22).

#+begin_src C :noweb-ref Token header data structures
typedef enum {
    TOKEN_NIL,
    TOKEN_TRUE,
    TOKEN_FALSE,
    TOKEN_SYMBOL,
    TOKEN_INT,
    TOKEN_FLOAT,
    TOKEN_STRING,
    TOKEN_CONS,
    TOKEN_LPAREN,
    TOKEN_RPAREN
} TokenType;

typedef struct Token {
    TokenType type;
    char *lexeme;
    uint8_t size;
} Token;
#+end_src


* Lisp Values

We are going to start reading an input stream to produce Lisp
Values. As per tradition, we stick all the possible values in the
=types.h= header file. C has two ways to imitate subtyping, one
uses a =struct { enum LispType type; union {...}; };= tagged-union
design, the other uses struct inheritance. I'll opt for the
latter.

The types we will have to implement:

1. The base "class" Lisp Value
2. Lisp Constants (for =nil=, =true=, and =false=)
3. Integer
4. Float
5. String
6. List
7. Symbol
8. Primitive Functions
9. Lisp Functions (constructed by lambdas)

#+begin_src C :tangle ../src/mal/types.h :noweb tangle
#ifndef LISP_TYPES_H
#define LISP_TYPES_H

typedef enum {
    LISP_NIL    = 0,  /* 0b00000000 */
    LISP_TRUE   = 1,  /* 0b00000001 */
    LISP_FALSE  = 2,  /* 0b00000010 */
    Lisp_BOOL   = 3,  /* 0b00000011 */
    LISP_SYMBOL = 4,  /* 0b00000100 */
    LISP_INT    = 8,  /* 0b00001000 */
    LISP_FLOAT  = 16, /* 0b00010000 */
    LISP_STRING = 32, /* 0b00100000 */
    LISP_CONS   = 64, /* 0b01000000 */
    <<Lisp type_enum constants>>
} LispType;

<<Lisp value base type>>

<<Lisp Numbers declarations>>

<<Lisp Symbol declarations>>

<<Lisp String declarations>>

<<Lisp cons-cell declarations>>

<<Other lisp types>>

#endif /* LISP_TYPES_H */
#+end_src

The headers we need for =types.c= include the usual suspects.

#+begin_src C :tangle ../src/mal/types.c :noweb tangle
/* types.c starts */
<<Include types headers>>
#+end_src

Which starts our source file off nicely:

#+begin_src C :noweb-ref Include types headers
/* <<Include types headers>> = */
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <stdbool.h>
#include "types.h"
#+end_src

** Base Type

The base type of Lisp Values tracks metadata, like the
=LispType type= constant, or reference counting. For now, I will
stick a pin in the topic of garbage collection (it's rather
tricky --- although [[https://nullprogram.com/blog/2015/02/17][reference counting in C]] is not too bad...thread
safety's a pain, though).

#+begin_src C :noweb no-export :noweb-ref Lisp value base type
/* types.h */
/* <<Lisp value base type>> = */
typedef struct LispValue {
    LispType type;
} LispValue;

LispValue* value_new(LispType type);
void value_free(LispValue *value);
#+end_src

*** Creating a new Value

We have the generic machinery for creating a =Value= for a given
=type=, without actually doing anything aside from allocating the
space for the metadata. If we cannot allocate memory, we abort.

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
LispValue* value_new(LispType type) {
    LispValue* value = malloc(sizeof(*value));
    if (!value) abort();
    value->type = type;
    return value;
}
#+end_src

*** Freeing a value

Freeing objects in memory is rather straightforward. If we had
refcounting, we would need to be a bit more careful. For future
considerations, we also dispatch depending on the type of value
being freed.

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
void value_free(LispValue *value) {
    if (!value) return;
    switch (value->type) {
        case LISP_NIL:    /* fall through */
        case LISP_TRUE:   /* fall through */
        case LISP_FALSE:
            return;       /* do not free constants */
        case LISP_SYMBOL:
            symbol_free((LispSymbol *)value);
            break;
        case LISP_INT:
            int_free((LispInt *)value);
            break;
        case LISP_FLOAT:
            float_free((LispFloat *)value);
            break;
        case LISP_STRING:
            string_free((LispString *)value);
            break;
        case LISP_CONS:
            list_free((LispList *)value);
            break;
        default:
            free(value);
    }
}
#+end_src



** Numbers

*** Header contributions

We have integers and floating-point numbers. I'm glossing over the
details, but really a double-precision number should be used (at
the very least) for floating-point arithmetic.

#+begin_src C :noweb no-export :noweb-ref Lisp Numbers declarations
/* types.h */
/* <<Lisp Numbers declarations>> = */

<<Lisp integer structure>>

<<Lisp integer function declarations>>

<<Lisp floating-point structure>>

<<Lisp floating-point function declarations>>
#+end_src

The data structure for the integer, I'll choose to use C's =long long=
data type. Heuristically, it's a suitably large integer type.

#+begin_src C :noweb no-export :noweb-ref Lisp integer structure
/* types.h */
/* <<Lisp integer structure>> = */

typedef struct LispInt {
    struct LispValue;
    long long value;
} LispInt;
#+end_src

The floating point could be either double or a =long double=. Since
there's no support anywhere for 128-bit floating point arithmetic,
I'm forced to use the next highest precision afforded by the IEEE 754
standard (double precision).

#+begin_src C :noweb no-export :noweb-ref Lisp floating-point structure
/* types.h */
/* <<Lisp floating-point structure>> = */
typedef struct LispFloat {
    struct LispValue;
    double value;
} LispFloat;
#+end_src

The function declarations for integer functions, although there
could be many, will support at least a simple constructor,
destructor, and a getter method.

#+begin_src C :noweb no-export :noweb-ref Lisp integer function declarations
/* types.h */
/* <<Lisp integer function declarations>> = */
LispInt* int_new(long long value);
void int_free(LispInt *integer);
long long int_get(LispInt *integer);
#+end_src

Likewise, we implement the corresponding methods for =LispFloat=.

#+begin_src C :noweb no-export :noweb-ref Lisp floating-point function declarations
/* types.h */
/* <<Lisp floating-point function declarations>> = */
LispFloat* float_new(double value);
void float_free(LispFloat *real);
double float_get(LispFloat *real);
#+end_src

*** Integer Constructor

We have the standard =malloc= then initialize.

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
LispInt* int_new(long long value) {
    LispInt* integer = malloc(sizeof(*integer));
    if (!integer) abort();
    integer->type = LISP_INT;
    integer->value = value;
    return integer;
}
#+end_src

*** Integer Destructor

We free the integer without much fanfare:

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
void int_free(LispInt *integer) {
    if (!integer) return;
    assert (LISP_INT == integer->type);

    free(integer);
}
#+end_src

*** Integer Getter

We want to hide the encapsulation...I guess we're doing that poorly
if we stick the struct in the header. Anyways, as per tradition:

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
long long int_get(LispInt *integer) {
    assert (NULL != integer);
    assert (LISP_INT == integer->type);
    return integer->value;
}
#+end_src


*** Float Constructor

Another =malloc= then initialize constructor:

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
LispFloat* float_new(double value) {
    LispFloat* real = malloc(sizeof(*real));
    if (!real) abort();
    real->type = LISP_FLOAT;
    real->value = value;
    return real;
}
#+end_src

*** Float Destructor

We free what we can:

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
void float_free(LispFloat *real) {
    if (!real) return;
    assert (LISP_FLOAT == real->type);
    free(real);
}
#+end_src

*** Float Getter

For a non-null real, we return its value (or raise an assertion
error if given a wrongly-typed term or null-pointer).

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
double float_get(LispFloat *real) {
    assert (NULL != real);
    assert (LISP_FLOAT == real->type);
    return real->value;
}
#+end_src

** Symbols

*** Header contributions

We need to define the data structure and declare the function
prototypes. This is the contribution to the types header.

#+begin_src C :noweb no-export :noweb-ref Lisp Symbol declarations
/* <<Lisp Symbol declarations>> = */

<<Symbol data structure>>

<<Symbol function declarations>>
#+end_src

A symbol amounts to a glorified string, alas.

#+begin_src C :noweb no-export :noweb-ref Symbol data structure
/* <<Symbol data structure>> = */

typedef struct LispSymbol {
    struct LispValue;
    char *name;
} LispSymbol;
#+end_src

There are three methods associated to a symbol. We have a
constructor, a destructor, and an ability to get a symbol's name:

#+begin_src C :noweb no-export :noweb-ref Symbol function declarations
/* <<Symbol function declarations>> = */

LispSymbol* symbol_new(char *name);
void symbol_free(LispSymbol *symbol);
char* symbol_name(LispSymbol *symbol);
#+end_src

*** Constant definitions

We define primitive constants
#+begin_src C :noweb no-export :noweb-ref Symbol data structure
/* <<Symbol data structure>> = */

extern const LispSymbol lisp_nil;
extern const LispSymbol lisp_true;
extern const LispSymbol lisp_false;
#+end_src

In the =reader.c= file, we just declare our initializers for the
constants =nil=, =true=, =false=:

#+begin_src C :noweb-ref String Token constants
/* <<String token constants>> = */

static char FALSE_TOKEN[] = "false";
static char NIL_TOKEN[] = "nil";
static char TRUE_TOKEN[] = "true";

const LispSymbol lisp_nil   = {.type = LISP_NIL, .name = NIL_TOKEN};
const LispSymbol lisp_true  = {.type = LISP_TRUE, .name = TRUE_TOKEN};
const LispSymbol lisp_false = {.type = LISP_FALSE, .name = FALSE_TOKEN};
#+end_src

*** Symbol Constructor

One corner-case to consider: what should happen if we try to
construct a symbol with a =NULL= name? I honestly do not know. It
seems reasonable to return =lisp_nil=, though this would be a
typing error. For now, I just create a new symbol.

The other consideration worth spending time pondering, should we
copy the string to the symbol? Or should we just reuse the string
we're given? Since the reader will create a lexeme, we should reuse
it here.

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
LispSymbol* symbol_new(char *name) {
    LispSymbol *symbol = malloc(sizeof(*symbol));
    symbol->type = LISP_SYMBOL;
    symbol->name = name;
    return symbol;
}
#+end_src

*** Symbol Destructor

Given the considerations weighed during the design of the
constructor, our hand is forced with the destructor: we need to
free the symbol name (or else we have a memory leak from the
=Reader= allocating a lexeme which is never freed).

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
void symbol_free(LispSymbol *symbol) {
    if (!symbol) return;
    assert (LISP_SYMBOL == symbol->type);
    if (symbol == lisp_nil || symbol == lisp_true || symbol == lisp_false) {
        // printf("WARNING: trying to free a constant\n");
        return;
    }
    if (symbol->name) free(symbol->name);
    free(symbol);
}
#+end_src

*** Symbol Name Getter

At present, I do not know if I will mutate the string returned from
=symbol_name=. I will assume not, and thus just return the pointer
directly.

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
char* symbol_name(LispSymbol *symbol) {
    assert(NULL != symbol);
    assert(LISP_SYMBOL == symbol->type);
    return symbol->name;
}
#+end_src

** Strings

Strings require greater consideration. Should we use "UCSD Pascal
Strings" (a struct tracking the size and the start of the character
string) or should we try to adopt something like Java's string
pool? The possibilities are endless.

The first attempt will make things as simple as possible, until
experience tells us we've done wrong.

*** Header Declarations

#+begin_src C :noweb no-export :noweb-ref Lisp String declarations
/* <<Lisp String declarations>> = */

<<String data structure>>

<<String function prototypes>>
#+end_src

The data structure lacks all the excitement of modern amenities.

#+begin_src C :noweb no-export :noweb-ref String data structure
/* <<String data structure>> = */

typedef struct LispString {
    struct LispValue;
    char *string;
} LispString;
#+end_src

And our function prototypes leave much to be desired. Later we will
have to consider how to design functions like:
- Substring
- Concatenation
- Case changes
- Whitespace stripping
- And much, much more!

For now, the holy trinity of constructor/destructor/getter
suffices.

#+begin_src C :noweb no-export :noweb-ref String function prototypes
/* <<String function prototypes>> = */

LispString* string_new(char *string);
void string_free(LispString *string);
char* string_get(LispString *string);
#+end_src

*** String Constructor

As with the symbol, we should dedicate some time to think about how
to handle the =NULL= string parameter case. "Should", but won't.

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
LispString* string_new(char *string) {
    LispString *s = malloc(sizeof(*s));
    if (!s) abort();
    s->type = LISP_STRING;
    s->string = string;
    return s;
}
#+end_src

*** String Destructor

Although we may accidentally try to destroy the same evidence
twice, we should handle it gracefully. Any non-null argument,
however, should be a =LispString= object.

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
void string_free(LispString *string) {
    if (!string) return;
    assert(LISP_STRING == string->type);
    if (string->string) free(string->string);
    free(string);
}
#+end_src

*** String getter

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
char* string_get(LispString *string) {
    assert (NULL != string);
    assert (LISP_STRING == string->type);
    return string->string;
}
#+end_src
** Lists

Lists in Lisp are linked-lists whose nodes are called
"cons-cells". They are mutatable in Common Lisp & Scheme, but
immutable in Clojure. We follow the great historic tradition of the
former, and leave considerations of the latter as an exercise for
the intrepid reader.

*** List Header Declarations

We have our data structure and function prototypes.

#+begin_src C :noweb no-export :noweb-ref Lisp cons-cell declarations
/* <<Lisp cons-cell declarations>> = */

<<List data structure>>

<<List function prototypes>>
#+end_src

Our data structure now takes advantage of the "struct polymorphism"
we implicitly have been building all along.

#+begin_src C :noweb no-export :noweb-ref List data structure
/* <<List data structure>> = */

typedef struct LispList {
    struct LispValue;
    LispValue *value;  /* cons */
    LispValue *next;   /* cdr */
} LispList;
#+end_src

The function prototypes include /two/ getter methods, in addition
to the constructor and destructor. There may be other helper
functions worth considering.

#+begin_src C :noweb no-export :noweb-ref List function prototypes
/* <<List function prototypes>> = */

LispList* list_new(LispValue *value, LispValue *next);
void list_free(LispList *list);
LispValue* list_car(LispList *list);
LispValue* list_cdr(LispList *list);
#+end_src

*** List Constructor

There are two cases worth considering: when =next= is =NULL= and
when it is not. When it is =NULL=, we should treat it as synonymous
with =lisp_nil=.

We also just set the pointers of the newly allocated list object to
the =value= and =next=. Immutability would require creating copies
of them, but I like to live dangerously.

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
LispList* list_new(LispValue *value, LispValue *next) {
    LispList *list = malloc(sizeof(*list));
    if (!list) abort();
    list->type = LISP_CONS;
    list->value = (NULL != value ? value : (LispValue *)&lisp_nil);
    list->next = (NULL != next ? next : (LispValue *)&lisp_nil);
    return list;
}
#+end_src

*** List Destructor

This is where reference counting would be really wonderful, since
it would handle freeing memory if I've painted myself into an
unreferenced corner. Instead, I'll defer that for now, and

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
void list_free(LispList *list) {
    if (!list) return;
    if ((LispValue *)list == (LispValue *)&lisp_nil) return;
    assert(LISP_CONS == list->type);
    free(list);
}
#+end_src

*** Car

The car accesses the value for a node. If we were given a =NULL=
pointer, following Common Lisp, we should return =nil=.

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
LispValue* list_car(LispList *list) {
    if (!list) return (LispValue *)&lisp_nil;
    assert (NULL != list);
    assert (LISP_CONS == list->type);
    return list->value;
}
#+end_src

*** Cdr

The cdr gives us the rest of the list. As with =car=, if given a
=NULL= pointer, we return =nil=.

#+begin_src C :tangle ../src/mal/types.c
/* types.c */
LispValue* list_cdr(LispList *list) {
    if (!list) return (LispValue *)&lisp_nil;
    assert (NULL != list);
    assert (LISP_CONS == list->type);
    return list->next;
}
#+end_src
* Evaluation

Lisp has the unique property that its programs are represented by
expressions of the language. Evaluating an expression depends on
whether the expression's "syntax tree" is atomic (e.g., literal
values or variables) or a list (for, e.g,, function calls).

#+begin_src C :noweb no-export
/* just to see if */
LispValue* eval_ast(LispValue *ast, Environment *env) {
    if (is_atom(ast)) {
        <<Evaluate atomic expressions>>
    } else {
        <<Evaluate list expressions>>
    }
}
#+end_src

** Evaluating Atomic Expressions

When we are evaluating a symbol, we treat it as the identifier for
a variable. Its evaluation should produce the value associated with
that identifier. The heavy lifting has been delegated to the
environment parameter of =eval_ast=.

#+begin_src C :noweb-ref Evaluate atomic expressions
/* <<Evaluate atomic expressions>> = */
switch (ast->type) {
    case LISP_SYMBOL:
        return env_lookup(env, ast->name);
    case LISP_NIL:    /* fall through */
    case LISP_TRUE:   /* fall through */
    case LISP_FALSE:  /* fall through */
    case LISP_STRING: /* fall through */
    case LISP_INT:    /* fall through */
    case LISP_FLOAT:
        return ast;
    default:
        char *msg = print_str(ast);
        fprintf(stderr, "ERROR: cannot evaluate %s\n", msg);
        free(msg);
        free(ast);
        abort();
}
#+end_src


** Evaluating List Expressions

Here things get interesting, because we have to take care of
special forms before trying to invoke the =car= as a function. We
take the convention that this is a sequence of =if ... else if ...=
statements trying to match on the first component of the list. In
each branch, there will be a =return= statement. Thus the default
branch amounts to invoking the function.

#+begin_src C :noweb no-export :noweb-ref Evaluate list expressions
/* <<Evaluate list expressions>> = */

<<Macroexpand the |ast|>>
<<Evaluate special forms>>
<<Evaluate list as function>>
#+end_src

** Special Forms

The special forms we'll implement are:
- =let*=
- =def!=
- =if=
- =fn*=
- =do=
- =quote=
- =quasiquote=
- =quasiquoteexpand=

*** Macros

These alone give us a good base to experiment with, but what Lisp would
we have without macros? The first implementation could be as simple as:

- =defmacro!=
- =macroexpand=

We could also experiment with first-class macros, analogous to =fn*=
we'd have something like =macro*=. The =defmacro! x [params] body= is just
=(def! defmacro! [macro-name params & body] `(def! ~macro-name (macro* ~params ~@body)))=.
But given =defmacro!=, it's difficult to obtain something like =macro*=
out of it.

*** Exception handling

An optional special form, for people familiar with Java-esque exception
handling:

- =try*=
- =catch*=

* Printing
* References

- Peter Henderson,
  {{{book-title(Functional Programming: Application and Implementation)}}}.
  Prentice-Hall International series in CS, 1980.
- Christian Queinnec,
  [[https://pages.lip6.fr/Christian.Queinnec/PDF/rl.pdf][Reasonable Lisp]] (1989)
- Christian Queinnec,
  {{{book-title(Lisp in Small Pieces)}}}.
  Cambridge University Press, 1996.
- Guy Steele, Jr.,
  {{{book-title(Common Lisp: The Language)}}}.
  Second ed.
